Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program function
Rule 3     program -> program declaration Semi
Rule 4     program -> empty
Rule 5     type -> Int
Rule 6     function -> type Identifier LParen params RParen Semi
Rule 7     function -> type Identifier LParen params RParen LBrace block RBrace
Rule 8     params -> empty
Rule 9     params -> params param_item
Rule 10    param_item -> declaration
Rule 11    param_item -> Comma declaration
Rule 12    block -> block block_item
Rule 13    block -> empty
Rule 14    block_item -> statement
Rule 15    block_item -> declaration Semi
Rule 16    statement -> statement_matched
Rule 17    statement -> statement_unmatched
Rule 18    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 19    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 20    statement_unmatched -> If LParen expression RParen statement
Rule 21    statement_matched -> While LParen expression RParen statement_matched
Rule 22    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 23    statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched
Rule 24    statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched
Rule 25    statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched
Rule 26    statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched
Rule 27    statement_matched -> For LParen Semi expression Semi expression RParen statement_matched
Rule 28    statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched
Rule 29    statement_matched -> For LParen expression Semi Semi expression RParen statement_matched
Rule 30    statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched
Rule 31    statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched
Rule 32    statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched
Rule 33    statement_matched -> For LParen expression Semi expression Semi RParen statement_matched
Rule 34    statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched
Rule 35    statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched
Rule 36    statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched
Rule 37    statement_matched -> For LParen expression Semi Semi RParen statement_matched
Rule 38    statement_matched -> For LParen declaration Semi Semi RParen statement_matched
Rule 39    statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched
Rule 40    statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched
Rule 41    statement_matched -> For LParen Semi expression Semi RParen statement_matched
Rule 42    statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched
Rule 43    statement_matched -> For LParen Semi Semi expression RParen statement_matched
Rule 44    statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched
Rule 45    statement_matched -> For LParen Semi Semi RParen statement_matched
Rule 46    statement_unmatched -> For LParen Semi Semi RParen statement_unmatched
Rule 47    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 48    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 49    statement_matched -> Return expression Semi
Rule 50    statement_matched -> opt_expression Semi
Rule 51    statement_matched -> LBrace block RBrace
Rule 52    statement_matched -> Break Semi
Rule 53    statement_matched -> Continue Semi
Rule 54    opt_expression -> expression
Rule 55    opt_expression -> empty
Rule 56    declaration -> type Identifier index
Rule 57    index -> index LBracket Integer RBracket
Rule 58    index -> index LBracket RBracket
Rule 59    index -> empty
Rule 60    declaration -> type Identifier index Assign LBrace Initlist RBrace
Rule 61    Initlist -> empty
Rule 62    Initlist -> Initlist init_item
Rule 63    init_item -> Integer
Rule 64    init_item -> Comma Integer
Rule 65    declaration -> type Identifier Assign expression
Rule 66    expression -> assignment
Rule 67    assignment -> conditional
Rule 68    conditional -> logical_or
Rule 69    logical_or -> logical_and
Rule 70    logical_and -> bit_or
Rule 71    bit_or -> xor
Rule 72    xor -> bit_and
Rule 73    bit_and -> equality
Rule 74    equality -> relational
Rule 75    relational -> additive
Rule 76    additive -> multiplicative
Rule 77    multiplicative -> unary
Rule 78    unary -> postfix
Rule 79    postfix -> primary
Rule 80    unary -> Minus unary
Rule 81    unary -> BitNot unary
Rule 82    unary -> Not unary
Rule 83    postfix -> Identifier LParen arguments RParen
Rule 84    postfix -> postfix LBracket expression RBracket
Rule 85    arguments -> empty
Rule 86    arguments -> arguments argument_item
Rule 87    argument_item -> Comma expression
Rule 88    argument_item -> expression
Rule 89    assignment -> Identifier Assign expression
Rule 90    assignment -> unary Assign expression
Rule 91    logical_or -> logical_or Or logical_and
Rule 92    logical_and -> logical_and And bit_or
Rule 93    bit_or -> bit_or BitOr xor
Rule 94    xor -> xor Xor bit_and
Rule 95    bit_and -> bit_and BitAnd equality
Rule 96    equality -> equality NotEqual relational
Rule 97    equality -> equality Equal relational
Rule 98    relational -> relational Less additive
Rule 99    relational -> relational Greater additive
Rule 100   relational -> relational LessEqual additive
Rule 101   relational -> relational GreaterEqual additive
Rule 102   additive -> additive Plus multiplicative
Rule 103   additive -> additive Minus multiplicative
Rule 104   multiplicative -> multiplicative Mul unary
Rule 105   multiplicative -> multiplicative Div unary
Rule 106   multiplicative -> multiplicative Mod unary
Rule 107   conditional -> logical_or Question expression Colon conditional
Rule 108   primary -> Integer
Rule 109   primary -> Identifier
Rule 110   primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 92
Assign               : 60 65 89 90
BitAnd               : 95
BitNot               : 81
BitOr                : 93
Break                : 52
Colon                : 107
Comma                : 11 64 87
Continue             : 53
Div                  : 105
Do                   : 47 48
Else                 : 18 19
Equal                : 97
For                  : 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
Greater              : 99
GreaterEqual         : 101
Identifier           : 6 7 56 60 65 83 89 109
If                   : 18 19 20
Int                  : 5
Integer              : 57 63 64 108
LBrace               : 7 51 60
LBracket             : 57 58 84
LParen               : 6 7 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 83 110
Less                 : 98
LessEqual            : 100
Minus                : 80 103
Mod                  : 106
Mul                  : 104
Not                  : 82
NotEqual             : 96
Or                   : 91
Plus                 : 102
Question             : 107
RBrace               : 7 51 60
RBracket             : 57 58 84
RParen               : 6 7 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 83 110
Return               : 49
Semi                 : 3 6 15 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 48 49 50 52 53
While                : 21 22 47 48
Xor                  : 94
error                : 

Nonterminals, with rules where they appear

Initlist             : 60 62
additive             : 75 98 99 100 101 102 103
argument_item        : 86
arguments            : 83 86
assignment           : 66
bit_and              : 72 94 95
bit_or               : 70 92 93
block                : 7 12 51
block_item           : 12
conditional          : 67 107
declaration          : 3 10 11 15 24 26 30 32 34 36 38 40
empty                : 4 8 13 55 59 61 85
equality             : 73 95 96 97
expression           : 18 19 20 21 22 23 23 23 24 24 25 25 25 26 26 27 27 28 28 29 29 30 31 31 32 33 33 34 35 35 36 37 39 41 42 43 44 47 48 49 54 65 84 87 88 89 90 107 110
function             : 2
index                : 56 57 58 60
init_item            : 62
logical_and          : 69 91 92
logical_or           : 68 91 107
multiplicative       : 76 102 103 104 105 106
opt_expression       : 50
param_item           : 9
params               : 6 7 9
postfix              : 78 84
primary              : 79
program              : 2 3 0
relational           : 74 96 97 98 99 100 101
statement            : 14 20
statement_matched    : 16 18 18 19 21 23 24 27 29 30 33 34 37 38 41 43 45 47
statement_unmatched  : 17 19 22 25 26 28 31 32 35 36 39 40 42 44 46 48
type                 : 6 7 56 60 65
unary                : 77 80 81 82 90 104 105 106
xor                  : 71 93 94

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program function
    (3) program -> . program declaration Semi
    (4) program -> . empty
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . function
    (3) program -> program . declaration Semi
    (6) function -> . type Identifier LParen params RParen Semi
    (7) function -> . type Identifier LParen params RParen LBrace block RBrace
    (56) declaration -> . type Identifier index
    (60) declaration -> . type Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> . type Identifier Assign expression
    (5) type -> . Int

    Int             shift and go to state 6

    function                       shift and go to state 3
    declaration                    shift and go to state 4
    type                           shift and go to state 5

state 2

    (4) program -> empty .

    Int             reduce using rule 4 (program -> empty .)
    $end            reduce using rule 4 (program -> empty .)


state 3

    (2) program -> program function .

    Int             reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 4

    (3) program -> program declaration . Semi

    Semi            shift and go to state 7


state 5

    (6) function -> type . Identifier LParen params RParen Semi
    (7) function -> type . Identifier LParen params RParen LBrace block RBrace
    (56) declaration -> type . Identifier index
    (60) declaration -> type . Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 8


state 6

    (5) type -> Int .

    Identifier      reduce using rule 5 (type -> Int .)


state 7

    (3) program -> program declaration Semi .

    Int             reduce using rule 3 (program -> program declaration Semi .)
    $end            reduce using rule 3 (program -> program declaration Semi .)


state 8

    (6) function -> type Identifier . LParen params RParen Semi
    (7) function -> type Identifier . LParen params RParen LBrace block RBrace
    (56) declaration -> type Identifier . index
    (60) declaration -> type Identifier . index Assign LBrace Initlist RBrace
    (65) declaration -> type Identifier . Assign expression
    (57) index -> . index LBracket Integer RBracket
    (58) index -> . index LBracket RBracket
    (59) index -> . empty
    (1) empty -> .

  ! shift/reduce conflict for Assign resolved as shift
    LParen          shift and go to state 9
    Assign          shift and go to state 11
    LBracket        reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

  ! Assign          [ reduce using rule 1 (empty -> .) ]

    index                          shift and go to state 10
    empty                          shift and go to state 12

state 9

    (6) function -> type Identifier LParen . params RParen Semi
    (7) function -> type Identifier LParen . params RParen LBrace block RBrace
    (8) params -> . empty
    (9) params -> . params param_item
    (1) empty -> .

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)

    params                         shift and go to state 13
    empty                          shift and go to state 14

state 10

    (56) declaration -> type Identifier index .
    (60) declaration -> type Identifier index . Assign LBrace Initlist RBrace
    (57) index -> index . LBracket Integer RBracket
    (58) index -> index . LBracket RBracket

    Semi            reduce using rule 56 (declaration -> type Identifier index .)
    RParen          reduce using rule 56 (declaration -> type Identifier index .)
    Comma           reduce using rule 56 (declaration -> type Identifier index .)
    Int             reduce using rule 56 (declaration -> type Identifier index .)
    Assign          shift and go to state 15
    LBracket        shift and go to state 16


state 11

    (65) declaration -> type Identifier Assign . expression
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 18
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 12

    (59) index -> empty .

    Assign          reduce using rule 59 (index -> empty .)
    LBracket        reduce using rule 59 (index -> empty .)
    Semi            reduce using rule 59 (index -> empty .)
    RParen          reduce using rule 59 (index -> empty .)
    Comma           reduce using rule 59 (index -> empty .)
    Int             reduce using rule 59 (index -> empty .)


state 13

    (6) function -> type Identifier LParen params . RParen Semi
    (7) function -> type Identifier LParen params . RParen LBrace block RBrace
    (9) params -> params . param_item
    (10) param_item -> . declaration
    (11) param_item -> . Comma declaration
    (56) declaration -> . type Identifier index
    (60) declaration -> . type Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> . type Identifier Assign expression
    (5) type -> . Int

    RParen          shift and go to state 39
    Comma           shift and go to state 42
    Int             shift and go to state 6

    type                           shift and go to state 38
    param_item                     shift and go to state 40
    declaration                    shift and go to state 41

state 14

    (8) params -> empty .

    RParen          reduce using rule 8 (params -> empty .)
    Comma           reduce using rule 8 (params -> empty .)
    Int             reduce using rule 8 (params -> empty .)


state 15

    (60) declaration -> type Identifier index Assign . LBrace Initlist RBrace

    LBrace          shift and go to state 43


state 16

    (57) index -> index LBracket . Integer RBracket
    (58) index -> index LBracket . RBracket

    Integer         shift and go to state 44
    RBracket        shift and go to state 45


state 17

    (89) assignment -> Identifier . Assign expression
    (83) postfix -> Identifier . LParen arguments RParen
    (109) primary -> Identifier .

  ! shift/reduce conflict for Assign resolved as shift
  ! shift/reduce conflict for LParen resolved as shift
    Assign          shift and go to state 46
    LParen          shift and go to state 47
    LBracket        reduce using rule 109 (primary -> Identifier .)
    Mul             reduce using rule 109 (primary -> Identifier .)
    Div             reduce using rule 109 (primary -> Identifier .)
    Mod             reduce using rule 109 (primary -> Identifier .)
    Plus            reduce using rule 109 (primary -> Identifier .)
    Minus           reduce using rule 109 (primary -> Identifier .)
    Less            reduce using rule 109 (primary -> Identifier .)
    Greater         reduce using rule 109 (primary -> Identifier .)
    LessEqual       reduce using rule 109 (primary -> Identifier .)
    GreaterEqual    reduce using rule 109 (primary -> Identifier .)
    NotEqual        reduce using rule 109 (primary -> Identifier .)
    Equal           reduce using rule 109 (primary -> Identifier .)
    BitAnd          reduce using rule 109 (primary -> Identifier .)
    Xor             reduce using rule 109 (primary -> Identifier .)
    BitOr           reduce using rule 109 (primary -> Identifier .)
    And             reduce using rule 109 (primary -> Identifier .)
    Question        reduce using rule 109 (primary -> Identifier .)
    Or              reduce using rule 109 (primary -> Identifier .)
    Semi            reduce using rule 109 (primary -> Identifier .)
    RParen          reduce using rule 109 (primary -> Identifier .)
    Comma           reduce using rule 109 (primary -> Identifier .)
    Int             reduce using rule 109 (primary -> Identifier .)
    Colon           reduce using rule 109 (primary -> Identifier .)
    RBracket        reduce using rule 109 (primary -> Identifier .)
    Identifier      reduce using rule 109 (primary -> Identifier .)
    BitNot          reduce using rule 109 (primary -> Identifier .)
    Not             reduce using rule 109 (primary -> Identifier .)
    Integer         reduce using rule 109 (primary -> Identifier .)

  ! Assign          [ reduce using rule 109 (primary -> Identifier .) ]
  ! LParen          [ reduce using rule 109 (primary -> Identifier .) ]


state 18

    (65) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 65 (declaration -> type Identifier Assign expression .)
    RParen          reduce using rule 65 (declaration -> type Identifier Assign expression .)
    Comma           reduce using rule 65 (declaration -> type Identifier Assign expression .)
    Int             reduce using rule 65 (declaration -> type Identifier Assign expression .)


state 19

    (66) expression -> assignment .

    Semi            reduce using rule 66 (expression -> assignment .)
    RParen          reduce using rule 66 (expression -> assignment .)
    Comma           reduce using rule 66 (expression -> assignment .)
    Int             reduce using rule 66 (expression -> assignment .)
    Colon           reduce using rule 66 (expression -> assignment .)
    RBracket        reduce using rule 66 (expression -> assignment .)
    Identifier      reduce using rule 66 (expression -> assignment .)
    Minus           reduce using rule 66 (expression -> assignment .)
    BitNot          reduce using rule 66 (expression -> assignment .)
    Not             reduce using rule 66 (expression -> assignment .)
    Integer         reduce using rule 66 (expression -> assignment .)
    LParen          reduce using rule 66 (expression -> assignment .)


state 20

    (67) assignment -> conditional .

    Semi            reduce using rule 67 (assignment -> conditional .)
    RParen          reduce using rule 67 (assignment -> conditional .)
    Comma           reduce using rule 67 (assignment -> conditional .)
    Int             reduce using rule 67 (assignment -> conditional .)
    Colon           reduce using rule 67 (assignment -> conditional .)
    RBracket        reduce using rule 67 (assignment -> conditional .)
    Identifier      reduce using rule 67 (assignment -> conditional .)
    Minus           reduce using rule 67 (assignment -> conditional .)
    BitNot          reduce using rule 67 (assignment -> conditional .)
    Not             reduce using rule 67 (assignment -> conditional .)
    Integer         reduce using rule 67 (assignment -> conditional .)
    LParen          reduce using rule 67 (assignment -> conditional .)


state 21

    (90) assignment -> unary . Assign expression
    (77) multiplicative -> unary .

    Assign          shift and go to state 48
    Mul             reduce using rule 77 (multiplicative -> unary .)
    Div             reduce using rule 77 (multiplicative -> unary .)
    Mod             reduce using rule 77 (multiplicative -> unary .)
    Plus            reduce using rule 77 (multiplicative -> unary .)
    Minus           reduce using rule 77 (multiplicative -> unary .)
    Less            reduce using rule 77 (multiplicative -> unary .)
    Greater         reduce using rule 77 (multiplicative -> unary .)
    LessEqual       reduce using rule 77 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 77 (multiplicative -> unary .)
    NotEqual        reduce using rule 77 (multiplicative -> unary .)
    Equal           reduce using rule 77 (multiplicative -> unary .)
    BitAnd          reduce using rule 77 (multiplicative -> unary .)
    Xor             reduce using rule 77 (multiplicative -> unary .)
    BitOr           reduce using rule 77 (multiplicative -> unary .)
    And             reduce using rule 77 (multiplicative -> unary .)
    Question        reduce using rule 77 (multiplicative -> unary .)
    Or              reduce using rule 77 (multiplicative -> unary .)
    Semi            reduce using rule 77 (multiplicative -> unary .)
    RParen          reduce using rule 77 (multiplicative -> unary .)
    Comma           reduce using rule 77 (multiplicative -> unary .)
    Int             reduce using rule 77 (multiplicative -> unary .)
    Colon           reduce using rule 77 (multiplicative -> unary .)
    RBracket        reduce using rule 77 (multiplicative -> unary .)
    Identifier      reduce using rule 77 (multiplicative -> unary .)
    BitNot          reduce using rule 77 (multiplicative -> unary .)
    Not             reduce using rule 77 (multiplicative -> unary .)
    Integer         reduce using rule 77 (multiplicative -> unary .)
    LParen          reduce using rule 77 (multiplicative -> unary .)


state 22

    (68) conditional -> logical_or .
    (107) conditional -> logical_or . Question expression Colon conditional
    (91) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 68 (conditional -> logical_or .)
    RParen          reduce using rule 68 (conditional -> logical_or .)
    Comma           reduce using rule 68 (conditional -> logical_or .)
    Int             reduce using rule 68 (conditional -> logical_or .)
    Colon           reduce using rule 68 (conditional -> logical_or .)
    RBracket        reduce using rule 68 (conditional -> logical_or .)
    Identifier      reduce using rule 68 (conditional -> logical_or .)
    Minus           reduce using rule 68 (conditional -> logical_or .)
    BitNot          reduce using rule 68 (conditional -> logical_or .)
    Not             reduce using rule 68 (conditional -> logical_or .)
    Integer         reduce using rule 68 (conditional -> logical_or .)
    LParen          reduce using rule 68 (conditional -> logical_or .)
    Question        shift and go to state 49
    Or              shift and go to state 50


state 23

    (78) unary -> postfix .
    (84) postfix -> postfix . LBracket expression RBracket

    Assign          reduce using rule 78 (unary -> postfix .)
    Mul             reduce using rule 78 (unary -> postfix .)
    Div             reduce using rule 78 (unary -> postfix .)
    Mod             reduce using rule 78 (unary -> postfix .)
    Plus            reduce using rule 78 (unary -> postfix .)
    Minus           reduce using rule 78 (unary -> postfix .)
    Less            reduce using rule 78 (unary -> postfix .)
    Greater         reduce using rule 78 (unary -> postfix .)
    LessEqual       reduce using rule 78 (unary -> postfix .)
    GreaterEqual    reduce using rule 78 (unary -> postfix .)
    NotEqual        reduce using rule 78 (unary -> postfix .)
    Equal           reduce using rule 78 (unary -> postfix .)
    BitAnd          reduce using rule 78 (unary -> postfix .)
    Xor             reduce using rule 78 (unary -> postfix .)
    BitOr           reduce using rule 78 (unary -> postfix .)
    And             reduce using rule 78 (unary -> postfix .)
    Question        reduce using rule 78 (unary -> postfix .)
    Or              reduce using rule 78 (unary -> postfix .)
    Semi            reduce using rule 78 (unary -> postfix .)
    RParen          reduce using rule 78 (unary -> postfix .)
    Comma           reduce using rule 78 (unary -> postfix .)
    Int             reduce using rule 78 (unary -> postfix .)
    Colon           reduce using rule 78 (unary -> postfix .)
    RBracket        reduce using rule 78 (unary -> postfix .)
    Identifier      reduce using rule 78 (unary -> postfix .)
    BitNot          reduce using rule 78 (unary -> postfix .)
    Not             reduce using rule 78 (unary -> postfix .)
    Integer         reduce using rule 78 (unary -> postfix .)
    LParen          reduce using rule 78 (unary -> postfix .)
    LBracket        shift and go to state 51


state 24

    (80) unary -> Minus . unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    unary                          shift and go to state 52
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 25

    (81) unary -> BitNot . unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    unary                          shift and go to state 54
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 26

    (82) unary -> Not . unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    unary                          shift and go to state 55
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 27

    (69) logical_or -> logical_and .
    (92) logical_and -> logical_and . And bit_or

    Question        reduce using rule 69 (logical_or -> logical_and .)
    Or              reduce using rule 69 (logical_or -> logical_and .)
    Semi            reduce using rule 69 (logical_or -> logical_and .)
    RParen          reduce using rule 69 (logical_or -> logical_and .)
    Comma           reduce using rule 69 (logical_or -> logical_and .)
    Int             reduce using rule 69 (logical_or -> logical_and .)
    Colon           reduce using rule 69 (logical_or -> logical_and .)
    RBracket        reduce using rule 69 (logical_or -> logical_and .)
    Identifier      reduce using rule 69 (logical_or -> logical_and .)
    Minus           reduce using rule 69 (logical_or -> logical_and .)
    BitNot          reduce using rule 69 (logical_or -> logical_and .)
    Not             reduce using rule 69 (logical_or -> logical_and .)
    Integer         reduce using rule 69 (logical_or -> logical_and .)
    LParen          reduce using rule 69 (logical_or -> logical_and .)
    And             shift and go to state 56


state 28

    (79) postfix -> primary .

    LBracket        reduce using rule 79 (postfix -> primary .)
    Assign          reduce using rule 79 (postfix -> primary .)
    Mul             reduce using rule 79 (postfix -> primary .)
    Div             reduce using rule 79 (postfix -> primary .)
    Mod             reduce using rule 79 (postfix -> primary .)
    Plus            reduce using rule 79 (postfix -> primary .)
    Minus           reduce using rule 79 (postfix -> primary .)
    Less            reduce using rule 79 (postfix -> primary .)
    Greater         reduce using rule 79 (postfix -> primary .)
    LessEqual       reduce using rule 79 (postfix -> primary .)
    GreaterEqual    reduce using rule 79 (postfix -> primary .)
    NotEqual        reduce using rule 79 (postfix -> primary .)
    Equal           reduce using rule 79 (postfix -> primary .)
    BitAnd          reduce using rule 79 (postfix -> primary .)
    Xor             reduce using rule 79 (postfix -> primary .)
    BitOr           reduce using rule 79 (postfix -> primary .)
    And             reduce using rule 79 (postfix -> primary .)
    Question        reduce using rule 79 (postfix -> primary .)
    Or              reduce using rule 79 (postfix -> primary .)
    Semi            reduce using rule 79 (postfix -> primary .)
    RParen          reduce using rule 79 (postfix -> primary .)
    Comma           reduce using rule 79 (postfix -> primary .)
    Int             reduce using rule 79 (postfix -> primary .)
    Colon           reduce using rule 79 (postfix -> primary .)
    RBracket        reduce using rule 79 (postfix -> primary .)
    Identifier      reduce using rule 79 (postfix -> primary .)
    BitNot          reduce using rule 79 (postfix -> primary .)
    Not             reduce using rule 79 (postfix -> primary .)
    Integer         reduce using rule 79 (postfix -> primary .)
    LParen          reduce using rule 79 (postfix -> primary .)


state 29

    (110) primary -> LParen . expression RParen
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 57
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 30

    (70) logical_and -> bit_or .
    (93) bit_or -> bit_or . BitOr xor

    And             reduce using rule 70 (logical_and -> bit_or .)
    Question        reduce using rule 70 (logical_and -> bit_or .)
    Or              reduce using rule 70 (logical_and -> bit_or .)
    Semi            reduce using rule 70 (logical_and -> bit_or .)
    RParen          reduce using rule 70 (logical_and -> bit_or .)
    Comma           reduce using rule 70 (logical_and -> bit_or .)
    Int             reduce using rule 70 (logical_and -> bit_or .)
    Colon           reduce using rule 70 (logical_and -> bit_or .)
    RBracket        reduce using rule 70 (logical_and -> bit_or .)
    Identifier      reduce using rule 70 (logical_and -> bit_or .)
    Minus           reduce using rule 70 (logical_and -> bit_or .)
    BitNot          reduce using rule 70 (logical_and -> bit_or .)
    Not             reduce using rule 70 (logical_and -> bit_or .)
    Integer         reduce using rule 70 (logical_and -> bit_or .)
    LParen          reduce using rule 70 (logical_and -> bit_or .)
    BitOr           shift and go to state 58


state 31

    (108) primary -> Integer .

    LBracket        reduce using rule 108 (primary -> Integer .)
    Assign          reduce using rule 108 (primary -> Integer .)
    Mul             reduce using rule 108 (primary -> Integer .)
    Div             reduce using rule 108 (primary -> Integer .)
    Mod             reduce using rule 108 (primary -> Integer .)
    Plus            reduce using rule 108 (primary -> Integer .)
    Minus           reduce using rule 108 (primary -> Integer .)
    Less            reduce using rule 108 (primary -> Integer .)
    Greater         reduce using rule 108 (primary -> Integer .)
    LessEqual       reduce using rule 108 (primary -> Integer .)
    GreaterEqual    reduce using rule 108 (primary -> Integer .)
    NotEqual        reduce using rule 108 (primary -> Integer .)
    Equal           reduce using rule 108 (primary -> Integer .)
    BitAnd          reduce using rule 108 (primary -> Integer .)
    Xor             reduce using rule 108 (primary -> Integer .)
    BitOr           reduce using rule 108 (primary -> Integer .)
    And             reduce using rule 108 (primary -> Integer .)
    Question        reduce using rule 108 (primary -> Integer .)
    Or              reduce using rule 108 (primary -> Integer .)
    Semi            reduce using rule 108 (primary -> Integer .)
    RParen          reduce using rule 108 (primary -> Integer .)
    Comma           reduce using rule 108 (primary -> Integer .)
    Int             reduce using rule 108 (primary -> Integer .)
    Colon           reduce using rule 108 (primary -> Integer .)
    RBracket        reduce using rule 108 (primary -> Integer .)
    Identifier      reduce using rule 108 (primary -> Integer .)
    BitNot          reduce using rule 108 (primary -> Integer .)
    Not             reduce using rule 108 (primary -> Integer .)
    Integer         reduce using rule 108 (primary -> Integer .)
    LParen          reduce using rule 108 (primary -> Integer .)


state 32

    (71) bit_or -> xor .
    (94) xor -> xor . Xor bit_and

    BitOr           reduce using rule 71 (bit_or -> xor .)
    And             reduce using rule 71 (bit_or -> xor .)
    Question        reduce using rule 71 (bit_or -> xor .)
    Or              reduce using rule 71 (bit_or -> xor .)
    Semi            reduce using rule 71 (bit_or -> xor .)
    RParen          reduce using rule 71 (bit_or -> xor .)
    Comma           reduce using rule 71 (bit_or -> xor .)
    Int             reduce using rule 71 (bit_or -> xor .)
    Colon           reduce using rule 71 (bit_or -> xor .)
    RBracket        reduce using rule 71 (bit_or -> xor .)
    Identifier      reduce using rule 71 (bit_or -> xor .)
    Minus           reduce using rule 71 (bit_or -> xor .)
    BitNot          reduce using rule 71 (bit_or -> xor .)
    Not             reduce using rule 71 (bit_or -> xor .)
    Integer         reduce using rule 71 (bit_or -> xor .)
    LParen          reduce using rule 71 (bit_or -> xor .)
    Xor             shift and go to state 59


state 33

    (72) xor -> bit_and .
    (95) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 72 (xor -> bit_and .)
    BitOr           reduce using rule 72 (xor -> bit_and .)
    And             reduce using rule 72 (xor -> bit_and .)
    Question        reduce using rule 72 (xor -> bit_and .)
    Or              reduce using rule 72 (xor -> bit_and .)
    Semi            reduce using rule 72 (xor -> bit_and .)
    RParen          reduce using rule 72 (xor -> bit_and .)
    Comma           reduce using rule 72 (xor -> bit_and .)
    Int             reduce using rule 72 (xor -> bit_and .)
    Colon           reduce using rule 72 (xor -> bit_and .)
    RBracket        reduce using rule 72 (xor -> bit_and .)
    Identifier      reduce using rule 72 (xor -> bit_and .)
    Minus           reduce using rule 72 (xor -> bit_and .)
    BitNot          reduce using rule 72 (xor -> bit_and .)
    Not             reduce using rule 72 (xor -> bit_and .)
    Integer         reduce using rule 72 (xor -> bit_and .)
    LParen          reduce using rule 72 (xor -> bit_and .)
    BitAnd          shift and go to state 60


state 34

    (73) bit_and -> equality .
    (96) equality -> equality . NotEqual relational
    (97) equality -> equality . Equal relational

    BitAnd          reduce using rule 73 (bit_and -> equality .)
    Xor             reduce using rule 73 (bit_and -> equality .)
    BitOr           reduce using rule 73 (bit_and -> equality .)
    And             reduce using rule 73 (bit_and -> equality .)
    Question        reduce using rule 73 (bit_and -> equality .)
    Or              reduce using rule 73 (bit_and -> equality .)
    Semi            reduce using rule 73 (bit_and -> equality .)
    RParen          reduce using rule 73 (bit_and -> equality .)
    Comma           reduce using rule 73 (bit_and -> equality .)
    Int             reduce using rule 73 (bit_and -> equality .)
    Colon           reduce using rule 73 (bit_and -> equality .)
    RBracket        reduce using rule 73 (bit_and -> equality .)
    Identifier      reduce using rule 73 (bit_and -> equality .)
    Minus           reduce using rule 73 (bit_and -> equality .)
    BitNot          reduce using rule 73 (bit_and -> equality .)
    Not             reduce using rule 73 (bit_and -> equality .)
    Integer         reduce using rule 73 (bit_and -> equality .)
    LParen          reduce using rule 73 (bit_and -> equality .)
    NotEqual        shift and go to state 61
    Equal           shift and go to state 62


state 35

    (74) equality -> relational .
    (98) relational -> relational . Less additive
    (99) relational -> relational . Greater additive
    (100) relational -> relational . LessEqual additive
    (101) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 74 (equality -> relational .)
    Equal           reduce using rule 74 (equality -> relational .)
    BitAnd          reduce using rule 74 (equality -> relational .)
    Xor             reduce using rule 74 (equality -> relational .)
    BitOr           reduce using rule 74 (equality -> relational .)
    And             reduce using rule 74 (equality -> relational .)
    Question        reduce using rule 74 (equality -> relational .)
    Or              reduce using rule 74 (equality -> relational .)
    Semi            reduce using rule 74 (equality -> relational .)
    RParen          reduce using rule 74 (equality -> relational .)
    Comma           reduce using rule 74 (equality -> relational .)
    Int             reduce using rule 74 (equality -> relational .)
    Colon           reduce using rule 74 (equality -> relational .)
    RBracket        reduce using rule 74 (equality -> relational .)
    Identifier      reduce using rule 74 (equality -> relational .)
    Minus           reduce using rule 74 (equality -> relational .)
    BitNot          reduce using rule 74 (equality -> relational .)
    Not             reduce using rule 74 (equality -> relational .)
    Integer         reduce using rule 74 (equality -> relational .)
    LParen          reduce using rule 74 (equality -> relational .)
    Less            shift and go to state 63
    Greater         shift and go to state 64
    LessEqual       shift and go to state 65
    GreaterEqual    shift and go to state 66


state 36

    (75) relational -> additive .
    (102) additive -> additive . Plus multiplicative
    (103) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 75 (relational -> additive .)
    Greater         reduce using rule 75 (relational -> additive .)
    LessEqual       reduce using rule 75 (relational -> additive .)
    GreaterEqual    reduce using rule 75 (relational -> additive .)
    NotEqual        reduce using rule 75 (relational -> additive .)
    Equal           reduce using rule 75 (relational -> additive .)
    BitAnd          reduce using rule 75 (relational -> additive .)
    Xor             reduce using rule 75 (relational -> additive .)
    BitOr           reduce using rule 75 (relational -> additive .)
    And             reduce using rule 75 (relational -> additive .)
    Question        reduce using rule 75 (relational -> additive .)
    Or              reduce using rule 75 (relational -> additive .)
    Semi            reduce using rule 75 (relational -> additive .)
    RParen          reduce using rule 75 (relational -> additive .)
    Comma           reduce using rule 75 (relational -> additive .)
    Int             reduce using rule 75 (relational -> additive .)
    Colon           reduce using rule 75 (relational -> additive .)
    RBracket        reduce using rule 75 (relational -> additive .)
    Identifier      reduce using rule 75 (relational -> additive .)
    BitNot          reduce using rule 75 (relational -> additive .)
    Not             reduce using rule 75 (relational -> additive .)
    Integer         reduce using rule 75 (relational -> additive .)
    LParen          reduce using rule 75 (relational -> additive .)
    Plus            shift and go to state 67
    Minus           shift and go to state 68

  ! Minus           [ reduce using rule 75 (relational -> additive .) ]


state 37

    (76) additive -> multiplicative .
    (104) multiplicative -> multiplicative . Mul unary
    (105) multiplicative -> multiplicative . Div unary
    (106) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 76 (additive -> multiplicative .)
    Minus           reduce using rule 76 (additive -> multiplicative .)
    Less            reduce using rule 76 (additive -> multiplicative .)
    Greater         reduce using rule 76 (additive -> multiplicative .)
    LessEqual       reduce using rule 76 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 76 (additive -> multiplicative .)
    NotEqual        reduce using rule 76 (additive -> multiplicative .)
    Equal           reduce using rule 76 (additive -> multiplicative .)
    BitAnd          reduce using rule 76 (additive -> multiplicative .)
    Xor             reduce using rule 76 (additive -> multiplicative .)
    BitOr           reduce using rule 76 (additive -> multiplicative .)
    And             reduce using rule 76 (additive -> multiplicative .)
    Question        reduce using rule 76 (additive -> multiplicative .)
    Or              reduce using rule 76 (additive -> multiplicative .)
    Semi            reduce using rule 76 (additive -> multiplicative .)
    RParen          reduce using rule 76 (additive -> multiplicative .)
    Comma           reduce using rule 76 (additive -> multiplicative .)
    Int             reduce using rule 76 (additive -> multiplicative .)
    Colon           reduce using rule 76 (additive -> multiplicative .)
    RBracket        reduce using rule 76 (additive -> multiplicative .)
    Identifier      reduce using rule 76 (additive -> multiplicative .)
    BitNot          reduce using rule 76 (additive -> multiplicative .)
    Not             reduce using rule 76 (additive -> multiplicative .)
    Integer         reduce using rule 76 (additive -> multiplicative .)
    LParen          reduce using rule 76 (additive -> multiplicative .)
    Mul             shift and go to state 69
    Div             shift and go to state 70
    Mod             shift and go to state 71


state 38

    (56) declaration -> type . Identifier index
    (60) declaration -> type . Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 72


state 39

    (6) function -> type Identifier LParen params RParen . Semi
    (7) function -> type Identifier LParen params RParen . LBrace block RBrace

    Semi            shift and go to state 73
    LBrace          shift and go to state 74


state 40

    (9) params -> params param_item .

    RParen          reduce using rule 9 (params -> params param_item .)
    Comma           reduce using rule 9 (params -> params param_item .)
    Int             reduce using rule 9 (params -> params param_item .)


state 41

    (10) param_item -> declaration .

    RParen          reduce using rule 10 (param_item -> declaration .)
    Comma           reduce using rule 10 (param_item -> declaration .)
    Int             reduce using rule 10 (param_item -> declaration .)


state 42

    (11) param_item -> Comma . declaration
    (56) declaration -> . type Identifier index
    (60) declaration -> . type Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> . type Identifier Assign expression
    (5) type -> . Int

    Int             shift and go to state 6

    declaration                    shift and go to state 75
    type                           shift and go to state 38

state 43

    (60) declaration -> type Identifier index Assign LBrace . Initlist RBrace
    (61) Initlist -> . empty
    (62) Initlist -> . Initlist init_item
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    Initlist                       shift and go to state 76
    empty                          shift and go to state 77

state 44

    (57) index -> index LBracket Integer . RBracket

    RBracket        shift and go to state 78


state 45

    (58) index -> index LBracket RBracket .

    Assign          reduce using rule 58 (index -> index LBracket RBracket .)
    LBracket        reduce using rule 58 (index -> index LBracket RBracket .)
    Semi            reduce using rule 58 (index -> index LBracket RBracket .)
    RParen          reduce using rule 58 (index -> index LBracket RBracket .)
    Comma           reduce using rule 58 (index -> index LBracket RBracket .)
    Int             reduce using rule 58 (index -> index LBracket RBracket .)


state 46

    (89) assignment -> Identifier Assign . expression
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 79
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 47

    (83) postfix -> Identifier LParen . arguments RParen
    (85) arguments -> . empty
    (86) arguments -> . arguments argument_item
    (1) empty -> .

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)

    arguments                      shift and go to state 80
    empty                          shift and go to state 81

state 48

    (90) assignment -> unary Assign . expression
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    unary                          shift and go to state 21
    expression                     shift and go to state 82
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 49

    (107) conditional -> logical_or Question . expression Colon conditional
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    logical_or                     shift and go to state 22
    expression                     shift and go to state 83
    conditional                    shift and go to state 20
    assignment                     shift and go to state 19
    unary                          shift and go to state 21
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 50

    (91) logical_or -> logical_or Or . logical_and
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    logical_and                    shift and go to state 84
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 51

    (84) postfix -> postfix LBracket . expression RBracket
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    postfix                        shift and go to state 23
    expression                     shift and go to state 86
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 52

    (80) unary -> Minus unary .

    Assign          reduce using rule 80 (unary -> Minus unary .)
    Mul             reduce using rule 80 (unary -> Minus unary .)
    Div             reduce using rule 80 (unary -> Minus unary .)
    Mod             reduce using rule 80 (unary -> Minus unary .)
    Plus            reduce using rule 80 (unary -> Minus unary .)
    Minus           reduce using rule 80 (unary -> Minus unary .)
    Less            reduce using rule 80 (unary -> Minus unary .)
    Greater         reduce using rule 80 (unary -> Minus unary .)
    LessEqual       reduce using rule 80 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 80 (unary -> Minus unary .)
    NotEqual        reduce using rule 80 (unary -> Minus unary .)
    Equal           reduce using rule 80 (unary -> Minus unary .)
    BitAnd          reduce using rule 80 (unary -> Minus unary .)
    Xor             reduce using rule 80 (unary -> Minus unary .)
    BitOr           reduce using rule 80 (unary -> Minus unary .)
    And             reduce using rule 80 (unary -> Minus unary .)
    Question        reduce using rule 80 (unary -> Minus unary .)
    Or              reduce using rule 80 (unary -> Minus unary .)
    Semi            reduce using rule 80 (unary -> Minus unary .)
    RParen          reduce using rule 80 (unary -> Minus unary .)
    Comma           reduce using rule 80 (unary -> Minus unary .)
    Int             reduce using rule 80 (unary -> Minus unary .)
    Colon           reduce using rule 80 (unary -> Minus unary .)
    RBracket        reduce using rule 80 (unary -> Minus unary .)
    Identifier      reduce using rule 80 (unary -> Minus unary .)
    BitNot          reduce using rule 80 (unary -> Minus unary .)
    Not             reduce using rule 80 (unary -> Minus unary .)
    Integer         reduce using rule 80 (unary -> Minus unary .)
    LParen          reduce using rule 80 (unary -> Minus unary .)


state 53

    (83) postfix -> Identifier . LParen arguments RParen
    (109) primary -> Identifier .

  ! shift/reduce conflict for LParen resolved as shift
    LParen          shift and go to state 47
    LBracket        reduce using rule 109 (primary -> Identifier .)
    Assign          reduce using rule 109 (primary -> Identifier .)
    Mul             reduce using rule 109 (primary -> Identifier .)
    Div             reduce using rule 109 (primary -> Identifier .)
    Mod             reduce using rule 109 (primary -> Identifier .)
    Plus            reduce using rule 109 (primary -> Identifier .)
    Minus           reduce using rule 109 (primary -> Identifier .)
    Less            reduce using rule 109 (primary -> Identifier .)
    Greater         reduce using rule 109 (primary -> Identifier .)
    LessEqual       reduce using rule 109 (primary -> Identifier .)
    GreaterEqual    reduce using rule 109 (primary -> Identifier .)
    NotEqual        reduce using rule 109 (primary -> Identifier .)
    Equal           reduce using rule 109 (primary -> Identifier .)
    BitAnd          reduce using rule 109 (primary -> Identifier .)
    Xor             reduce using rule 109 (primary -> Identifier .)
    BitOr           reduce using rule 109 (primary -> Identifier .)
    And             reduce using rule 109 (primary -> Identifier .)
    Question        reduce using rule 109 (primary -> Identifier .)
    Or              reduce using rule 109 (primary -> Identifier .)
    Semi            reduce using rule 109 (primary -> Identifier .)
    RParen          reduce using rule 109 (primary -> Identifier .)
    Comma           reduce using rule 109 (primary -> Identifier .)
    Int             reduce using rule 109 (primary -> Identifier .)
    Colon           reduce using rule 109 (primary -> Identifier .)
    RBracket        reduce using rule 109 (primary -> Identifier .)
    Identifier      reduce using rule 109 (primary -> Identifier .)
    BitNot          reduce using rule 109 (primary -> Identifier .)
    Not             reduce using rule 109 (primary -> Identifier .)
    Integer         reduce using rule 109 (primary -> Identifier .)

  ! LParen          [ reduce using rule 109 (primary -> Identifier .) ]


state 54

    (81) unary -> BitNot unary .

    Assign          reduce using rule 81 (unary -> BitNot unary .)
    Mul             reduce using rule 81 (unary -> BitNot unary .)
    Div             reduce using rule 81 (unary -> BitNot unary .)
    Mod             reduce using rule 81 (unary -> BitNot unary .)
    Plus            reduce using rule 81 (unary -> BitNot unary .)
    Minus           reduce using rule 81 (unary -> BitNot unary .)
    Less            reduce using rule 81 (unary -> BitNot unary .)
    Greater         reduce using rule 81 (unary -> BitNot unary .)
    LessEqual       reduce using rule 81 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 81 (unary -> BitNot unary .)
    NotEqual        reduce using rule 81 (unary -> BitNot unary .)
    Equal           reduce using rule 81 (unary -> BitNot unary .)
    BitAnd          reduce using rule 81 (unary -> BitNot unary .)
    Xor             reduce using rule 81 (unary -> BitNot unary .)
    BitOr           reduce using rule 81 (unary -> BitNot unary .)
    And             reduce using rule 81 (unary -> BitNot unary .)
    Question        reduce using rule 81 (unary -> BitNot unary .)
    Or              reduce using rule 81 (unary -> BitNot unary .)
    Semi            reduce using rule 81 (unary -> BitNot unary .)
    RParen          reduce using rule 81 (unary -> BitNot unary .)
    Comma           reduce using rule 81 (unary -> BitNot unary .)
    Int             reduce using rule 81 (unary -> BitNot unary .)
    Colon           reduce using rule 81 (unary -> BitNot unary .)
    RBracket        reduce using rule 81 (unary -> BitNot unary .)
    Identifier      reduce using rule 81 (unary -> BitNot unary .)
    BitNot          reduce using rule 81 (unary -> BitNot unary .)
    Not             reduce using rule 81 (unary -> BitNot unary .)
    Integer         reduce using rule 81 (unary -> BitNot unary .)
    LParen          reduce using rule 81 (unary -> BitNot unary .)


state 55

    (82) unary -> Not unary .

    Assign          reduce using rule 82 (unary -> Not unary .)
    Mul             reduce using rule 82 (unary -> Not unary .)
    Div             reduce using rule 82 (unary -> Not unary .)
    Mod             reduce using rule 82 (unary -> Not unary .)
    Plus            reduce using rule 82 (unary -> Not unary .)
    Minus           reduce using rule 82 (unary -> Not unary .)
    Less            reduce using rule 82 (unary -> Not unary .)
    Greater         reduce using rule 82 (unary -> Not unary .)
    LessEqual       reduce using rule 82 (unary -> Not unary .)
    GreaterEqual    reduce using rule 82 (unary -> Not unary .)
    NotEqual        reduce using rule 82 (unary -> Not unary .)
    Equal           reduce using rule 82 (unary -> Not unary .)
    BitAnd          reduce using rule 82 (unary -> Not unary .)
    Xor             reduce using rule 82 (unary -> Not unary .)
    BitOr           reduce using rule 82 (unary -> Not unary .)
    And             reduce using rule 82 (unary -> Not unary .)
    Question        reduce using rule 82 (unary -> Not unary .)
    Or              reduce using rule 82 (unary -> Not unary .)
    Semi            reduce using rule 82 (unary -> Not unary .)
    RParen          reduce using rule 82 (unary -> Not unary .)
    Comma           reduce using rule 82 (unary -> Not unary .)
    Int             reduce using rule 82 (unary -> Not unary .)
    Colon           reduce using rule 82 (unary -> Not unary .)
    RBracket        reduce using rule 82 (unary -> Not unary .)
    Identifier      reduce using rule 82 (unary -> Not unary .)
    BitNot          reduce using rule 82 (unary -> Not unary .)
    Not             reduce using rule 82 (unary -> Not unary .)
    Integer         reduce using rule 82 (unary -> Not unary .)
    LParen          reduce using rule 82 (unary -> Not unary .)


state 56

    (92) logical_and -> logical_and And . bit_or
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    bit_or                         shift and go to state 87
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 57

    (110) primary -> LParen expression . RParen

    RParen          shift and go to state 88


state 58

    (93) bit_or -> bit_or BitOr . xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    xor                            shift and go to state 89
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 59

    (94) xor -> xor Xor . bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    bit_and                        shift and go to state 90
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 60

    (95) bit_and -> bit_and BitAnd . equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    equality                       shift and go to state 91
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 61

    (96) equality -> equality NotEqual . relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    relational                     shift and go to state 92
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 62

    (97) equality -> equality Equal . relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    relational                     shift and go to state 93
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 63

    (98) relational -> relational Less . additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    additive                       shift and go to state 94
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 64

    (99) relational -> relational Greater . additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    additive                       shift and go to state 95
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 65

    (100) relational -> relational LessEqual . additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    additive                       shift and go to state 96
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 66

    (101) relational -> relational GreaterEqual . additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    additive                       shift and go to state 97
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 67

    (102) additive -> additive Plus . multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    multiplicative                 shift and go to state 98
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 68

    (103) additive -> additive Minus . multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    multiplicative                 shift and go to state 99
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 69

    (104) multiplicative -> multiplicative Mul . unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    unary                          shift and go to state 100
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 70

    (105) multiplicative -> multiplicative Div . unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    unary                          shift and go to state 101
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 71

    (106) multiplicative -> multiplicative Mod . unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    unary                          shift and go to state 102
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 72

    (56) declaration -> type Identifier . index
    (60) declaration -> type Identifier . index Assign LBrace Initlist RBrace
    (65) declaration -> type Identifier . Assign expression
    (57) index -> . index LBracket Integer RBracket
    (58) index -> . index LBracket RBracket
    (59) index -> . empty
    (1) empty -> .

  ! shift/reduce conflict for Assign resolved as shift
    Assign          shift and go to state 11
    LBracket        reduce using rule 1 (empty -> .)
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

  ! Assign          [ reduce using rule 1 (empty -> .) ]

    index                          shift and go to state 10
    empty                          shift and go to state 12

state 73

    (6) function -> type Identifier LParen params RParen Semi .

    Int             reduce using rule 6 (function -> type Identifier LParen params RParen Semi .)
    $end            reduce using rule 6 (function -> type Identifier LParen params RParen Semi .)


state 74

    (7) function -> type Identifier LParen params RParen LBrace . block RBrace
    (12) block -> . block block_item
    (13) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 103
    empty                          shift and go to state 104

state 75

    (11) param_item -> Comma declaration .

    RParen          reduce using rule 11 (param_item -> Comma declaration .)
    Comma           reduce using rule 11 (param_item -> Comma declaration .)
    Int             reduce using rule 11 (param_item -> Comma declaration .)


state 76

    (60) declaration -> type Identifier index Assign LBrace Initlist . RBrace
    (62) Initlist -> Initlist . init_item
    (63) init_item -> . Integer
    (64) init_item -> . Comma Integer

    RBrace          shift and go to state 105
    Integer         shift and go to state 107
    Comma           shift and go to state 108

    init_item                      shift and go to state 106

state 77

    (61) Initlist -> empty .

    RBrace          reduce using rule 61 (Initlist -> empty .)
    Integer         reduce using rule 61 (Initlist -> empty .)
    Comma           reduce using rule 61 (Initlist -> empty .)


state 78

    (57) index -> index LBracket Integer RBracket .

    Assign          reduce using rule 57 (index -> index LBracket Integer RBracket .)
    LBracket        reduce using rule 57 (index -> index LBracket Integer RBracket .)
    Semi            reduce using rule 57 (index -> index LBracket Integer RBracket .)
    RParen          reduce using rule 57 (index -> index LBracket Integer RBracket .)
    Comma           reduce using rule 57 (index -> index LBracket Integer RBracket .)
    Int             reduce using rule 57 (index -> index LBracket Integer RBracket .)


state 79

    (89) assignment -> Identifier Assign expression .

    Semi            reduce using rule 89 (assignment -> Identifier Assign expression .)
    RParen          reduce using rule 89 (assignment -> Identifier Assign expression .)
    Comma           reduce using rule 89 (assignment -> Identifier Assign expression .)
    Int             reduce using rule 89 (assignment -> Identifier Assign expression .)
    Colon           reduce using rule 89 (assignment -> Identifier Assign expression .)
    RBracket        reduce using rule 89 (assignment -> Identifier Assign expression .)
    Identifier      reduce using rule 89 (assignment -> Identifier Assign expression .)
    Minus           reduce using rule 89 (assignment -> Identifier Assign expression .)
    BitNot          reduce using rule 89 (assignment -> Identifier Assign expression .)
    Not             reduce using rule 89 (assignment -> Identifier Assign expression .)
    Integer         reduce using rule 89 (assignment -> Identifier Assign expression .)
    LParen          reduce using rule 89 (assignment -> Identifier Assign expression .)


state 80

    (83) postfix -> Identifier LParen arguments . RParen
    (86) arguments -> arguments . argument_item
    (87) argument_item -> . Comma expression
    (88) argument_item -> . expression
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RParen          shift and go to state 109
    Comma           shift and go to state 111
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    argument_item                  shift and go to state 110
    expression                     shift and go to state 112
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 81

    (85) arguments -> empty .

    RParen          reduce using rule 85 (arguments -> empty .)
    Comma           reduce using rule 85 (arguments -> empty .)
    Identifier      reduce using rule 85 (arguments -> empty .)
    Minus           reduce using rule 85 (arguments -> empty .)
    BitNot          reduce using rule 85 (arguments -> empty .)
    Not             reduce using rule 85 (arguments -> empty .)
    Integer         reduce using rule 85 (arguments -> empty .)
    LParen          reduce using rule 85 (arguments -> empty .)


state 82

    (90) assignment -> unary Assign expression .

    Semi            reduce using rule 90 (assignment -> unary Assign expression .)
    RParen          reduce using rule 90 (assignment -> unary Assign expression .)
    Comma           reduce using rule 90 (assignment -> unary Assign expression .)
    Int             reduce using rule 90 (assignment -> unary Assign expression .)
    Colon           reduce using rule 90 (assignment -> unary Assign expression .)
    RBracket        reduce using rule 90 (assignment -> unary Assign expression .)
    Identifier      reduce using rule 90 (assignment -> unary Assign expression .)
    Minus           reduce using rule 90 (assignment -> unary Assign expression .)
    BitNot          reduce using rule 90 (assignment -> unary Assign expression .)
    Not             reduce using rule 90 (assignment -> unary Assign expression .)
    Integer         reduce using rule 90 (assignment -> unary Assign expression .)
    LParen          reduce using rule 90 (assignment -> unary Assign expression .)


state 83

    (107) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 113


state 84

    (91) logical_or -> logical_or Or logical_and .
    (92) logical_and -> logical_and . And bit_or

    Question        reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Int             reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    RBracket        reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Identifier      reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Minus           reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    BitNot          reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Not             reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    Integer         reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    LParen          reduce using rule 91 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 56


state 85

    (77) multiplicative -> unary .

    Mul             reduce using rule 77 (multiplicative -> unary .)
    Div             reduce using rule 77 (multiplicative -> unary .)
    Mod             reduce using rule 77 (multiplicative -> unary .)
    Plus            reduce using rule 77 (multiplicative -> unary .)
    Minus           reduce using rule 77 (multiplicative -> unary .)
    Less            reduce using rule 77 (multiplicative -> unary .)
    Greater         reduce using rule 77 (multiplicative -> unary .)
    LessEqual       reduce using rule 77 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 77 (multiplicative -> unary .)
    NotEqual        reduce using rule 77 (multiplicative -> unary .)
    Equal           reduce using rule 77 (multiplicative -> unary .)
    BitAnd          reduce using rule 77 (multiplicative -> unary .)
    Xor             reduce using rule 77 (multiplicative -> unary .)
    BitOr           reduce using rule 77 (multiplicative -> unary .)
    And             reduce using rule 77 (multiplicative -> unary .)
    Question        reduce using rule 77 (multiplicative -> unary .)
    Or              reduce using rule 77 (multiplicative -> unary .)
    Semi            reduce using rule 77 (multiplicative -> unary .)
    RParen          reduce using rule 77 (multiplicative -> unary .)
    Comma           reduce using rule 77 (multiplicative -> unary .)
    Int             reduce using rule 77 (multiplicative -> unary .)
    Colon           reduce using rule 77 (multiplicative -> unary .)
    RBracket        reduce using rule 77 (multiplicative -> unary .)
    Identifier      reduce using rule 77 (multiplicative -> unary .)
    BitNot          reduce using rule 77 (multiplicative -> unary .)
    Not             reduce using rule 77 (multiplicative -> unary .)
    Integer         reduce using rule 77 (multiplicative -> unary .)
    LParen          reduce using rule 77 (multiplicative -> unary .)


state 86

    (84) postfix -> postfix LBracket expression . RBracket

    RBracket        shift and go to state 114


state 87

    (92) logical_and -> logical_and And bit_or .
    (93) bit_or -> bit_or . BitOr xor

    And             reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 92 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Int             reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 92 (logical_and -> logical_and And bit_or .)
    RBracket        reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Identifier      reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Minus           reduce using rule 92 (logical_and -> logical_and And bit_or .)
    BitNot          reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Not             reduce using rule 92 (logical_and -> logical_and And bit_or .)
    Integer         reduce using rule 92 (logical_and -> logical_and And bit_or .)
    LParen          reduce using rule 92 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 58


state 88

    (110) primary -> LParen expression RParen .

    LBracket        reduce using rule 110 (primary -> LParen expression RParen .)
    Assign          reduce using rule 110 (primary -> LParen expression RParen .)
    Mul             reduce using rule 110 (primary -> LParen expression RParen .)
    Div             reduce using rule 110 (primary -> LParen expression RParen .)
    Mod             reduce using rule 110 (primary -> LParen expression RParen .)
    Plus            reduce using rule 110 (primary -> LParen expression RParen .)
    Minus           reduce using rule 110 (primary -> LParen expression RParen .)
    Less            reduce using rule 110 (primary -> LParen expression RParen .)
    Greater         reduce using rule 110 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 110 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 110 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 110 (primary -> LParen expression RParen .)
    Equal           reduce using rule 110 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 110 (primary -> LParen expression RParen .)
    Xor             reduce using rule 110 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 110 (primary -> LParen expression RParen .)
    And             reduce using rule 110 (primary -> LParen expression RParen .)
    Question        reduce using rule 110 (primary -> LParen expression RParen .)
    Or              reduce using rule 110 (primary -> LParen expression RParen .)
    Semi            reduce using rule 110 (primary -> LParen expression RParen .)
    RParen          reduce using rule 110 (primary -> LParen expression RParen .)
    Comma           reduce using rule 110 (primary -> LParen expression RParen .)
    Int             reduce using rule 110 (primary -> LParen expression RParen .)
    Colon           reduce using rule 110 (primary -> LParen expression RParen .)
    RBracket        reduce using rule 110 (primary -> LParen expression RParen .)
    Identifier      reduce using rule 110 (primary -> LParen expression RParen .)
    BitNot          reduce using rule 110 (primary -> LParen expression RParen .)
    Not             reduce using rule 110 (primary -> LParen expression RParen .)
    Integer         reduce using rule 110 (primary -> LParen expression RParen .)
    LParen          reduce using rule 110 (primary -> LParen expression RParen .)


state 89

    (93) bit_or -> bit_or BitOr xor .
    (94) xor -> xor . Xor bit_and

    BitOr           reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Int             reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    RBracket        reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Identifier      reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Minus           reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    BitNot          reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Not             reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Integer         reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    LParen          reduce using rule 93 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 59


state 90

    (94) xor -> xor Xor bit_and .
    (95) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 94 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 94 (xor -> xor Xor bit_and .)
    And             reduce using rule 94 (xor -> xor Xor bit_and .)
    Question        reduce using rule 94 (xor -> xor Xor bit_and .)
    Or              reduce using rule 94 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 94 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 94 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 94 (xor -> xor Xor bit_and .)
    Int             reduce using rule 94 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 94 (xor -> xor Xor bit_and .)
    RBracket        reduce using rule 94 (xor -> xor Xor bit_and .)
    Identifier      reduce using rule 94 (xor -> xor Xor bit_and .)
    Minus           reduce using rule 94 (xor -> xor Xor bit_and .)
    BitNot          reduce using rule 94 (xor -> xor Xor bit_and .)
    Not             reduce using rule 94 (xor -> xor Xor bit_and .)
    Integer         reduce using rule 94 (xor -> xor Xor bit_and .)
    LParen          reduce using rule 94 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 60


state 91

    (95) bit_and -> bit_and BitAnd equality .
    (96) equality -> equality . NotEqual relational
    (97) equality -> equality . Equal relational

    BitAnd          reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Int             reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    RBracket        reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Identifier      reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Minus           reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    BitNot          reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Not             reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    Integer         reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    LParen          reduce using rule 95 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 61
    Equal           shift and go to state 62


state 92

    (96) equality -> equality NotEqual relational .
    (98) relational -> relational . Less additive
    (99) relational -> relational . Greater additive
    (100) relational -> relational . LessEqual additive
    (101) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 96 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 96 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 96 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 96 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 96 (equality -> equality NotEqual relational .)
    And             reduce using rule 96 (equality -> equality NotEqual relational .)
    Question        reduce using rule 96 (equality -> equality NotEqual relational .)
    Or              reduce using rule 96 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 96 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 96 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 96 (equality -> equality NotEqual relational .)
    Int             reduce using rule 96 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 96 (equality -> equality NotEqual relational .)
    RBracket        reduce using rule 96 (equality -> equality NotEqual relational .)
    Identifier      reduce using rule 96 (equality -> equality NotEqual relational .)
    Minus           reduce using rule 96 (equality -> equality NotEqual relational .)
    BitNot          reduce using rule 96 (equality -> equality NotEqual relational .)
    Not             reduce using rule 96 (equality -> equality NotEqual relational .)
    Integer         reduce using rule 96 (equality -> equality NotEqual relational .)
    LParen          reduce using rule 96 (equality -> equality NotEqual relational .)
    Less            shift and go to state 63
    Greater         shift and go to state 64
    LessEqual       shift and go to state 65
    GreaterEqual    shift and go to state 66


state 93

    (97) equality -> equality Equal relational .
    (98) relational -> relational . Less additive
    (99) relational -> relational . Greater additive
    (100) relational -> relational . LessEqual additive
    (101) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 97 (equality -> equality Equal relational .)
    Equal           reduce using rule 97 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 97 (equality -> equality Equal relational .)
    Xor             reduce using rule 97 (equality -> equality Equal relational .)
    BitOr           reduce using rule 97 (equality -> equality Equal relational .)
    And             reduce using rule 97 (equality -> equality Equal relational .)
    Question        reduce using rule 97 (equality -> equality Equal relational .)
    Or              reduce using rule 97 (equality -> equality Equal relational .)
    Semi            reduce using rule 97 (equality -> equality Equal relational .)
    RParen          reduce using rule 97 (equality -> equality Equal relational .)
    Comma           reduce using rule 97 (equality -> equality Equal relational .)
    Int             reduce using rule 97 (equality -> equality Equal relational .)
    Colon           reduce using rule 97 (equality -> equality Equal relational .)
    RBracket        reduce using rule 97 (equality -> equality Equal relational .)
    Identifier      reduce using rule 97 (equality -> equality Equal relational .)
    Minus           reduce using rule 97 (equality -> equality Equal relational .)
    BitNot          reduce using rule 97 (equality -> equality Equal relational .)
    Not             reduce using rule 97 (equality -> equality Equal relational .)
    Integer         reduce using rule 97 (equality -> equality Equal relational .)
    LParen          reduce using rule 97 (equality -> equality Equal relational .)
    Less            shift and go to state 63
    Greater         shift and go to state 64
    LessEqual       shift and go to state 65
    GreaterEqual    shift and go to state 66


state 94

    (98) relational -> relational Less additive .
    (102) additive -> additive . Plus multiplicative
    (103) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 98 (relational -> relational Less additive .)
    Greater         reduce using rule 98 (relational -> relational Less additive .)
    LessEqual       reduce using rule 98 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 98 (relational -> relational Less additive .)
    NotEqual        reduce using rule 98 (relational -> relational Less additive .)
    Equal           reduce using rule 98 (relational -> relational Less additive .)
    BitAnd          reduce using rule 98 (relational -> relational Less additive .)
    Xor             reduce using rule 98 (relational -> relational Less additive .)
    BitOr           reduce using rule 98 (relational -> relational Less additive .)
    And             reduce using rule 98 (relational -> relational Less additive .)
    Question        reduce using rule 98 (relational -> relational Less additive .)
    Or              reduce using rule 98 (relational -> relational Less additive .)
    Semi            reduce using rule 98 (relational -> relational Less additive .)
    RParen          reduce using rule 98 (relational -> relational Less additive .)
    Comma           reduce using rule 98 (relational -> relational Less additive .)
    Int             reduce using rule 98 (relational -> relational Less additive .)
    Colon           reduce using rule 98 (relational -> relational Less additive .)
    RBracket        reduce using rule 98 (relational -> relational Less additive .)
    Identifier      reduce using rule 98 (relational -> relational Less additive .)
    BitNot          reduce using rule 98 (relational -> relational Less additive .)
    Not             reduce using rule 98 (relational -> relational Less additive .)
    Integer         reduce using rule 98 (relational -> relational Less additive .)
    LParen          reduce using rule 98 (relational -> relational Less additive .)
    Plus            shift and go to state 67
    Minus           shift and go to state 68

  ! Minus           [ reduce using rule 98 (relational -> relational Less additive .) ]


state 95

    (99) relational -> relational Greater additive .
    (102) additive -> additive . Plus multiplicative
    (103) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 99 (relational -> relational Greater additive .)
    Greater         reduce using rule 99 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 99 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 99 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 99 (relational -> relational Greater additive .)
    Equal           reduce using rule 99 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 99 (relational -> relational Greater additive .)
    Xor             reduce using rule 99 (relational -> relational Greater additive .)
    BitOr           reduce using rule 99 (relational -> relational Greater additive .)
    And             reduce using rule 99 (relational -> relational Greater additive .)
    Question        reduce using rule 99 (relational -> relational Greater additive .)
    Or              reduce using rule 99 (relational -> relational Greater additive .)
    Semi            reduce using rule 99 (relational -> relational Greater additive .)
    RParen          reduce using rule 99 (relational -> relational Greater additive .)
    Comma           reduce using rule 99 (relational -> relational Greater additive .)
    Int             reduce using rule 99 (relational -> relational Greater additive .)
    Colon           reduce using rule 99 (relational -> relational Greater additive .)
    RBracket        reduce using rule 99 (relational -> relational Greater additive .)
    Identifier      reduce using rule 99 (relational -> relational Greater additive .)
    BitNot          reduce using rule 99 (relational -> relational Greater additive .)
    Not             reduce using rule 99 (relational -> relational Greater additive .)
    Integer         reduce using rule 99 (relational -> relational Greater additive .)
    LParen          reduce using rule 99 (relational -> relational Greater additive .)
    Plus            shift and go to state 67
    Minus           shift and go to state 68

  ! Minus           [ reduce using rule 99 (relational -> relational Greater additive .) ]


state 96

    (100) relational -> relational LessEqual additive .
    (102) additive -> additive . Plus multiplicative
    (103) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 100 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 100 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 100 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 100 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 100 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 100 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 100 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 100 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 100 (relational -> relational LessEqual additive .)
    And             reduce using rule 100 (relational -> relational LessEqual additive .)
    Question        reduce using rule 100 (relational -> relational LessEqual additive .)
    Or              reduce using rule 100 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 100 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 100 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 100 (relational -> relational LessEqual additive .)
    Int             reduce using rule 100 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 100 (relational -> relational LessEqual additive .)
    RBracket        reduce using rule 100 (relational -> relational LessEqual additive .)
    Identifier      reduce using rule 100 (relational -> relational LessEqual additive .)
    BitNot          reduce using rule 100 (relational -> relational LessEqual additive .)
    Not             reduce using rule 100 (relational -> relational LessEqual additive .)
    Integer         reduce using rule 100 (relational -> relational LessEqual additive .)
    LParen          reduce using rule 100 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 67
    Minus           shift and go to state 68

  ! Minus           [ reduce using rule 100 (relational -> relational LessEqual additive .) ]


state 97

    (101) relational -> relational GreaterEqual additive .
    (102) additive -> additive . Plus multiplicative
    (103) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 101 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 101 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 101 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 101 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 101 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 101 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 101 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Int             reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 101 (relational -> relational GreaterEqual additive .)
    RBracket        reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Identifier      reduce using rule 101 (relational -> relational GreaterEqual additive .)
    BitNot          reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Not             reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Integer         reduce using rule 101 (relational -> relational GreaterEqual additive .)
    LParen          reduce using rule 101 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 67
    Minus           shift and go to state 68

  ! Minus           [ reduce using rule 101 (relational -> relational GreaterEqual additive .) ]


state 98

    (102) additive -> additive Plus multiplicative .
    (104) multiplicative -> multiplicative . Mul unary
    (105) multiplicative -> multiplicative . Div unary
    (106) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 102 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 102 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 102 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 102 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 102 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 102 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 102 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 102 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 102 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 102 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 102 (additive -> additive Plus multiplicative .)
    And             reduce using rule 102 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 102 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 102 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 102 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 102 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 102 (additive -> additive Plus multiplicative .)
    Int             reduce using rule 102 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 102 (additive -> additive Plus multiplicative .)
    RBracket        reduce using rule 102 (additive -> additive Plus multiplicative .)
    Identifier      reduce using rule 102 (additive -> additive Plus multiplicative .)
    BitNot          reduce using rule 102 (additive -> additive Plus multiplicative .)
    Not             reduce using rule 102 (additive -> additive Plus multiplicative .)
    Integer         reduce using rule 102 (additive -> additive Plus multiplicative .)
    LParen          reduce using rule 102 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 69
    Div             shift and go to state 70
    Mod             shift and go to state 71


state 99

    (103) additive -> additive Minus multiplicative .
    (104) multiplicative -> multiplicative . Mul unary
    (105) multiplicative -> multiplicative . Div unary
    (106) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 103 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 103 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 103 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 103 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 103 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 103 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 103 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 103 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 103 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 103 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 103 (additive -> additive Minus multiplicative .)
    And             reduce using rule 103 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 103 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 103 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 103 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 103 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 103 (additive -> additive Minus multiplicative .)
    Int             reduce using rule 103 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 103 (additive -> additive Minus multiplicative .)
    RBracket        reduce using rule 103 (additive -> additive Minus multiplicative .)
    Identifier      reduce using rule 103 (additive -> additive Minus multiplicative .)
    BitNot          reduce using rule 103 (additive -> additive Minus multiplicative .)
    Not             reduce using rule 103 (additive -> additive Minus multiplicative .)
    Integer         reduce using rule 103 (additive -> additive Minus multiplicative .)
    LParen          reduce using rule 103 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 69
    Div             shift and go to state 70
    Mod             shift and go to state 71


state 100

    (104) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Int             reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    RBracket        reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Identifier      reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    BitNot          reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Not             reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    Integer         reduce using rule 104 (multiplicative -> multiplicative Mul unary .)
    LParen          reduce using rule 104 (multiplicative -> multiplicative Mul unary .)


state 101

    (105) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Int             reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    RBracket        reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Identifier      reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    BitNot          reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Not             reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    Integer         reduce using rule 105 (multiplicative -> multiplicative Div unary .)
    LParen          reduce using rule 105 (multiplicative -> multiplicative Div unary .)


state 102

    (106) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Int             reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    RBracket        reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Identifier      reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    BitNot          reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Not             reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    Integer         reduce using rule 106 (multiplicative -> multiplicative Mod unary .)
    LParen          reduce using rule 106 (multiplicative -> multiplicative Mod unary .)


state 103

    (7) function -> type Identifier LParen params RParen LBrace block . RBrace
    (12) block -> block . block_item
    (14) block_item -> . statement
    (15) block_item -> . declaration Semi
    (16) statement -> . statement_matched
    (17) statement -> . statement_unmatched
    (56) declaration -> . type Identifier index
    (60) declaration -> . type Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> . type Identifier Assign expression
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (5) type -> . Int
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RBrace          shift and go to state 116
    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    type                           shift and go to state 38
    block_item                     shift and go to state 117
    statement                      shift and go to state 118
    declaration                    shift and go to state 119
    statement_matched              shift and go to state 120
    statement_unmatched            shift and go to state 121
    expression                     shift and go to state 122
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 104

    (13) block -> empty .

    RBrace          reduce using rule 13 (block -> empty .)
    If              reduce using rule 13 (block -> empty .)
    While           reduce using rule 13 (block -> empty .)
    For             reduce using rule 13 (block -> empty .)
    Do              reduce using rule 13 (block -> empty .)
    Return          reduce using rule 13 (block -> empty .)
    LBrace          reduce using rule 13 (block -> empty .)
    Break           reduce using rule 13 (block -> empty .)
    Continue        reduce using rule 13 (block -> empty .)
    Int             reduce using rule 13 (block -> empty .)
    Identifier      reduce using rule 13 (block -> empty .)
    Minus           reduce using rule 13 (block -> empty .)
    BitNot          reduce using rule 13 (block -> empty .)
    Not             reduce using rule 13 (block -> empty .)
    Integer         reduce using rule 13 (block -> empty .)
    LParen          reduce using rule 13 (block -> empty .)
    Semi            reduce using rule 13 (block -> empty .)


state 105

    (60) declaration -> type Identifier index Assign LBrace Initlist RBrace .

    Semi            reduce using rule 60 (declaration -> type Identifier index Assign LBrace Initlist RBrace .)
    RParen          reduce using rule 60 (declaration -> type Identifier index Assign LBrace Initlist RBrace .)
    Comma           reduce using rule 60 (declaration -> type Identifier index Assign LBrace Initlist RBrace .)
    Int             reduce using rule 60 (declaration -> type Identifier index Assign LBrace Initlist RBrace .)


state 106

    (62) Initlist -> Initlist init_item .

    RBrace          reduce using rule 62 (Initlist -> Initlist init_item .)
    Integer         reduce using rule 62 (Initlist -> Initlist init_item .)
    Comma           reduce using rule 62 (Initlist -> Initlist init_item .)


state 107

    (63) init_item -> Integer .

    RBrace          reduce using rule 63 (init_item -> Integer .)
    Integer         reduce using rule 63 (init_item -> Integer .)
    Comma           reduce using rule 63 (init_item -> Integer .)


state 108

    (64) init_item -> Comma . Integer

    Integer         shift and go to state 132


state 109

    (83) postfix -> Identifier LParen arguments RParen .

    LBracket        reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Assign          reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Mul             reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Div             reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Mod             reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Plus            reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Minus           reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Less            reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Greater         reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    LessEqual       reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    GreaterEqual    reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    NotEqual        reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Equal           reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    BitAnd          reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Xor             reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    BitOr           reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    And             reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Question        reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Or              reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Semi            reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    RParen          reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Comma           reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Int             reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Colon           reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    RBracket        reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Identifier      reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    BitNot          reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Not             reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    Integer         reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)
    LParen          reduce using rule 83 (postfix -> Identifier LParen arguments RParen .)


state 110

    (86) arguments -> arguments argument_item .

    RParen          reduce using rule 86 (arguments -> arguments argument_item .)
    Comma           reduce using rule 86 (arguments -> arguments argument_item .)
    Identifier      reduce using rule 86 (arguments -> arguments argument_item .)
    Minus           reduce using rule 86 (arguments -> arguments argument_item .)
    BitNot          reduce using rule 86 (arguments -> arguments argument_item .)
    Not             reduce using rule 86 (arguments -> arguments argument_item .)
    Integer         reduce using rule 86 (arguments -> arguments argument_item .)
    LParen          reduce using rule 86 (arguments -> arguments argument_item .)


state 111

    (87) argument_item -> Comma . expression
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 133
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 112

    (88) argument_item -> expression .

    RParen          reduce using rule 88 (argument_item -> expression .)
    Comma           reduce using rule 88 (argument_item -> expression .)
    Identifier      reduce using rule 88 (argument_item -> expression .)
    Minus           reduce using rule 88 (argument_item -> expression .)
    BitNot          reduce using rule 88 (argument_item -> expression .)
    Not             reduce using rule 88 (argument_item -> expression .)
    Integer         reduce using rule 88 (argument_item -> expression .)
    LParen          reduce using rule 88 (argument_item -> expression .)


state 113

    (107) conditional -> logical_or Question expression Colon . conditional
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen

    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Identifier      shift and go to state 53
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    logical_or                     shift and go to state 22
    conditional                    shift and go to state 134
    logical_and                    shift and go to state 27
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37
    unary                          shift and go to state 85
    postfix                        shift and go to state 23
    primary                        shift and go to state 28

state 114

    (84) postfix -> postfix LBracket expression RBracket .

    LBracket        reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Assign          reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Mul             reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Div             reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Mod             reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Plus            reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Minus           reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Less            reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Greater         reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    LessEqual       reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    GreaterEqual    reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    NotEqual        reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Equal           reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    BitAnd          reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Xor             reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    BitOr           reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    And             reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Question        reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Or              reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Semi            reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    RParen          reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Comma           reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Int             reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Colon           reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    RBracket        reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Identifier      reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    BitNot          reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Not             reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    Integer         reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)
    LParen          reduce using rule 84 (postfix -> postfix LBracket expression RBracket .)


state 115

    (51) statement_matched -> LBrace . block RBrace
    (12) block -> . block block_item
    (13) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 135
    empty                          shift and go to state 104

state 116

    (7) function -> type Identifier LParen params RParen LBrace block RBrace .

    Int             reduce using rule 7 (function -> type Identifier LParen params RParen LBrace block RBrace .)
    $end            reduce using rule 7 (function -> type Identifier LParen params RParen LBrace block RBrace .)


state 117

    (12) block -> block block_item .

    RBrace          reduce using rule 12 (block -> block block_item .)
    If              reduce using rule 12 (block -> block block_item .)
    While           reduce using rule 12 (block -> block block_item .)
    For             reduce using rule 12 (block -> block block_item .)
    Do              reduce using rule 12 (block -> block block_item .)
    Return          reduce using rule 12 (block -> block block_item .)
    LBrace          reduce using rule 12 (block -> block block_item .)
    Break           reduce using rule 12 (block -> block block_item .)
    Continue        reduce using rule 12 (block -> block block_item .)
    Int             reduce using rule 12 (block -> block block_item .)
    Identifier      reduce using rule 12 (block -> block block_item .)
    Minus           reduce using rule 12 (block -> block block_item .)
    BitNot          reduce using rule 12 (block -> block block_item .)
    Not             reduce using rule 12 (block -> block block_item .)
    Integer         reduce using rule 12 (block -> block block_item .)
    LParen          reduce using rule 12 (block -> block block_item .)
    Semi            reduce using rule 12 (block -> block block_item .)


state 118

    (14) block_item -> statement .

    RBrace          reduce using rule 14 (block_item -> statement .)
    If              reduce using rule 14 (block_item -> statement .)
    While           reduce using rule 14 (block_item -> statement .)
    For             reduce using rule 14 (block_item -> statement .)
    Do              reduce using rule 14 (block_item -> statement .)
    Return          reduce using rule 14 (block_item -> statement .)
    LBrace          reduce using rule 14 (block_item -> statement .)
    Break           reduce using rule 14 (block_item -> statement .)
    Continue        reduce using rule 14 (block_item -> statement .)
    Int             reduce using rule 14 (block_item -> statement .)
    Identifier      reduce using rule 14 (block_item -> statement .)
    Minus           reduce using rule 14 (block_item -> statement .)
    BitNot          reduce using rule 14 (block_item -> statement .)
    Not             reduce using rule 14 (block_item -> statement .)
    Integer         reduce using rule 14 (block_item -> statement .)
    LParen          reduce using rule 14 (block_item -> statement .)
    Semi            reduce using rule 14 (block_item -> statement .)


state 119

    (15) block_item -> declaration . Semi

    Semi            shift and go to state 136


state 120

    (16) statement -> statement_matched .

    RBrace          reduce using rule 16 (statement -> statement_matched .)
    If              reduce using rule 16 (statement -> statement_matched .)
    While           reduce using rule 16 (statement -> statement_matched .)
    For             reduce using rule 16 (statement -> statement_matched .)
    Do              reduce using rule 16 (statement -> statement_matched .)
    Return          reduce using rule 16 (statement -> statement_matched .)
    LBrace          reduce using rule 16 (statement -> statement_matched .)
    Break           reduce using rule 16 (statement -> statement_matched .)
    Continue        reduce using rule 16 (statement -> statement_matched .)
    Int             reduce using rule 16 (statement -> statement_matched .)
    Identifier      reduce using rule 16 (statement -> statement_matched .)
    Minus           reduce using rule 16 (statement -> statement_matched .)
    BitNot          reduce using rule 16 (statement -> statement_matched .)
    Not             reduce using rule 16 (statement -> statement_matched .)
    Integer         reduce using rule 16 (statement -> statement_matched .)
    LParen          reduce using rule 16 (statement -> statement_matched .)
    Semi            reduce using rule 16 (statement -> statement_matched .)


state 121

    (17) statement -> statement_unmatched .

    RBrace          reduce using rule 17 (statement -> statement_unmatched .)
    If              reduce using rule 17 (statement -> statement_unmatched .)
    While           reduce using rule 17 (statement -> statement_unmatched .)
    For             reduce using rule 17 (statement -> statement_unmatched .)
    Do              reduce using rule 17 (statement -> statement_unmatched .)
    Return          reduce using rule 17 (statement -> statement_unmatched .)
    LBrace          reduce using rule 17 (statement -> statement_unmatched .)
    Break           reduce using rule 17 (statement -> statement_unmatched .)
    Continue        reduce using rule 17 (statement -> statement_unmatched .)
    Int             reduce using rule 17 (statement -> statement_unmatched .)
    Identifier      reduce using rule 17 (statement -> statement_unmatched .)
    Minus           reduce using rule 17 (statement -> statement_unmatched .)
    BitNot          reduce using rule 17 (statement -> statement_unmatched .)
    Not             reduce using rule 17 (statement -> statement_unmatched .)
    Integer         reduce using rule 17 (statement -> statement_unmatched .)
    LParen          reduce using rule 17 (statement -> statement_unmatched .)
    Semi            reduce using rule 17 (statement -> statement_unmatched .)


state 122

    (54) opt_expression -> expression .

    Semi            reduce using rule 54 (opt_expression -> expression .)


state 123

    (18) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (19) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 137


state 124

    (21) statement_matched -> While . LParen expression RParen statement_matched
    (22) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 138


state 125

    (23) statement_matched -> For . LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> For . LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> For . LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> For . LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> For . LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> For . LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> For . LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> For . LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> For . LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> For . LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> For . LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> For . LParen Semi Semi RParen statement_matched
    (25) statement_unmatched -> For . LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> For . LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> For . LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> For . LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For . LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> For . LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> For . LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> For . LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> For . LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> For . LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> For . LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> For . LParen Semi Semi RParen statement_unmatched

    LParen          shift and go to state 139


state 126

    (47) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (48) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    statement_matched              shift and go to state 140
    expression                     shift and go to state 122
    statement_unmatched            shift and go to state 141
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 127

    (49) statement_matched -> Return . expression Semi
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 142
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 128

    (50) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 143


state 129

    (52) statement_matched -> Break . Semi

    Semi            shift and go to state 144


state 130

    (53) statement_matched -> Continue . Semi

    Semi            shift and go to state 145


state 131

    (55) opt_expression -> empty .

    Semi            reduce using rule 55 (opt_expression -> empty .)


state 132

    (64) init_item -> Comma Integer .

    RBrace          reduce using rule 64 (init_item -> Comma Integer .)
    Integer         reduce using rule 64 (init_item -> Comma Integer .)
    Comma           reduce using rule 64 (init_item -> Comma Integer .)


state 133

    (87) argument_item -> Comma expression .

    RParen          reduce using rule 87 (argument_item -> Comma expression .)
    Comma           reduce using rule 87 (argument_item -> Comma expression .)
    Identifier      reduce using rule 87 (argument_item -> Comma expression .)
    Minus           reduce using rule 87 (argument_item -> Comma expression .)
    BitNot          reduce using rule 87 (argument_item -> Comma expression .)
    Not             reduce using rule 87 (argument_item -> Comma expression .)
    Integer         reduce using rule 87 (argument_item -> Comma expression .)
    LParen          reduce using rule 87 (argument_item -> Comma expression .)


state 134

    (107) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    Int             reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    RBracket        reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    Identifier      reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    Minus           reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    BitNot          reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    Not             reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    Integer         reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)
    LParen          reduce using rule 107 (conditional -> logical_or Question expression Colon conditional .)


state 135

    (51) statement_matched -> LBrace block . RBrace
    (12) block -> block . block_item
    (14) block_item -> . statement
    (15) block_item -> . declaration Semi
    (16) statement -> . statement_matched
    (17) statement -> . statement_unmatched
    (56) declaration -> . type Identifier index
    (60) declaration -> . type Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> . type Identifier Assign expression
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (5) type -> . Int
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RBrace          shift and go to state 146
    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    block_item                     shift and go to state 117
    statement                      shift and go to state 118
    declaration                    shift and go to state 119
    statement_matched              shift and go to state 120
    statement_unmatched            shift and go to state 121
    type                           shift and go to state 38
    expression                     shift and go to state 122
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 136

    (15) block_item -> declaration Semi .

    RBrace          reduce using rule 15 (block_item -> declaration Semi .)
    If              reduce using rule 15 (block_item -> declaration Semi .)
    While           reduce using rule 15 (block_item -> declaration Semi .)
    For             reduce using rule 15 (block_item -> declaration Semi .)
    Do              reduce using rule 15 (block_item -> declaration Semi .)
    Return          reduce using rule 15 (block_item -> declaration Semi .)
    LBrace          reduce using rule 15 (block_item -> declaration Semi .)
    Break           reduce using rule 15 (block_item -> declaration Semi .)
    Continue        reduce using rule 15 (block_item -> declaration Semi .)
    Int             reduce using rule 15 (block_item -> declaration Semi .)
    Identifier      reduce using rule 15 (block_item -> declaration Semi .)
    Minus           reduce using rule 15 (block_item -> declaration Semi .)
    BitNot          reduce using rule 15 (block_item -> declaration Semi .)
    Not             reduce using rule 15 (block_item -> declaration Semi .)
    Integer         reduce using rule 15 (block_item -> declaration Semi .)
    LParen          reduce using rule 15 (block_item -> declaration Semi .)
    Semi            reduce using rule 15 (block_item -> declaration Semi .)


state 137

    (18) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (19) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> If LParen . expression RParen statement
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 147
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 138

    (21) statement_matched -> While LParen . expression RParen statement_matched
    (22) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 148
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 139

    (23) statement_matched -> For LParen . expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> For LParen . declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> For LParen . Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> For LParen . expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> For LParen . declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> For LParen . expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> For LParen . declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> For LParen . expression Semi Semi RParen statement_matched
    (38) statement_matched -> For LParen . declaration Semi Semi RParen statement_matched
    (41) statement_matched -> For LParen . Semi expression Semi RParen statement_matched
    (43) statement_matched -> For LParen . Semi Semi expression RParen statement_matched
    (45) statement_matched -> For LParen . Semi Semi RParen statement_matched
    (25) statement_unmatched -> For LParen . expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> For LParen . declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> For LParen . Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen . expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen . declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> For LParen . expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> For LParen . declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> For LParen . expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> For LParen . declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> For LParen . Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> For LParen . Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> For LParen . Semi Semi RParen statement_unmatched
    (66) expression -> . assignment
    (56) declaration -> . type Identifier index
    (60) declaration -> . type Identifier index Assign LBrace Initlist RBrace
    (65) declaration -> . type Identifier Assign expression
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (5) type -> . Int
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Semi            shift and go to state 150
    Identifier      shift and go to state 17
    Int             shift and go to state 6
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 149
    declaration                    shift and go to state 151
    assignment                     shift and go to state 19
    type                           shift and go to state 38
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 140

    (47) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 152


state 141

    (48) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 153


state 142

    (49) statement_matched -> Return expression . Semi

    Semi            shift and go to state 154


state 143

    (50) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 50 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 50 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 50 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 50 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 50 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 50 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 50 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 50 (statement_matched -> opt_expression Semi .)


state 144

    (52) statement_matched -> Break Semi .

    RBrace          reduce using rule 52 (statement_matched -> Break Semi .)
    If              reduce using rule 52 (statement_matched -> Break Semi .)
    While           reduce using rule 52 (statement_matched -> Break Semi .)
    For             reduce using rule 52 (statement_matched -> Break Semi .)
    Do              reduce using rule 52 (statement_matched -> Break Semi .)
    Return          reduce using rule 52 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 52 (statement_matched -> Break Semi .)
    Break           reduce using rule 52 (statement_matched -> Break Semi .)
    Continue        reduce using rule 52 (statement_matched -> Break Semi .)
    Int             reduce using rule 52 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 52 (statement_matched -> Break Semi .)
    Minus           reduce using rule 52 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 52 (statement_matched -> Break Semi .)
    Not             reduce using rule 52 (statement_matched -> Break Semi .)
    Integer         reduce using rule 52 (statement_matched -> Break Semi .)
    LParen          reduce using rule 52 (statement_matched -> Break Semi .)
    Semi            reduce using rule 52 (statement_matched -> Break Semi .)
    Else            reduce using rule 52 (statement_matched -> Break Semi .)


state 145

    (53) statement_matched -> Continue Semi .

    RBrace          reduce using rule 53 (statement_matched -> Continue Semi .)
    If              reduce using rule 53 (statement_matched -> Continue Semi .)
    While           reduce using rule 53 (statement_matched -> Continue Semi .)
    For             reduce using rule 53 (statement_matched -> Continue Semi .)
    Do              reduce using rule 53 (statement_matched -> Continue Semi .)
    Return          reduce using rule 53 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 53 (statement_matched -> Continue Semi .)
    Break           reduce using rule 53 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 53 (statement_matched -> Continue Semi .)
    Int             reduce using rule 53 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 53 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 53 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 53 (statement_matched -> Continue Semi .)
    Not             reduce using rule 53 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 53 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 53 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 53 (statement_matched -> Continue Semi .)
    Else            reduce using rule 53 (statement_matched -> Continue Semi .)


state 146

    (51) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 51 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 51 (statement_matched -> LBrace block RBrace .)


state 147

    (18) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (19) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 155


state 148

    (21) statement_matched -> While LParen expression . RParen statement_matched
    (22) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 156


state 149

    (23) statement_matched -> For LParen expression . Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> For LParen expression . Semi Semi expression RParen statement_matched
    (33) statement_matched -> For LParen expression . Semi expression Semi RParen statement_matched
    (37) statement_matched -> For LParen expression . Semi Semi RParen statement_matched
    (25) statement_unmatched -> For LParen expression . Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen expression . Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> For LParen expression . Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> For LParen expression . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 157


state 150

    (27) statement_matched -> For LParen Semi . expression Semi expression RParen statement_matched
    (41) statement_matched -> For LParen Semi . expression Semi RParen statement_matched
    (43) statement_matched -> For LParen Semi . Semi expression RParen statement_matched
    (45) statement_matched -> For LParen Semi . Semi RParen statement_matched
    (28) statement_unmatched -> For LParen Semi . expression Semi expression RParen statement_unmatched
    (42) statement_unmatched -> For LParen Semi . expression Semi RParen statement_unmatched
    (44) statement_unmatched -> For LParen Semi . Semi expression RParen statement_unmatched
    (46) statement_unmatched -> For LParen Semi . Semi RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Semi            shift and go to state 158
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 159
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 151

    (24) statement_matched -> For LParen declaration . Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> For LParen declaration . Semi Semi expression RParen statement_matched
    (34) statement_matched -> For LParen declaration . Semi expression Semi RParen statement_matched
    (38) statement_matched -> For LParen declaration . Semi Semi RParen statement_matched
    (26) statement_unmatched -> For LParen declaration . Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen declaration . Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen declaration . Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> For LParen declaration . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 160


state 152

    (47) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 161


state 153

    (48) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 162


state 154

    (49) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 49 (statement_matched -> Return expression Semi .)
    If              reduce using rule 49 (statement_matched -> Return expression Semi .)
    While           reduce using rule 49 (statement_matched -> Return expression Semi .)
    For             reduce using rule 49 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 49 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 49 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 49 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 49 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 49 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 49 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 49 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 49 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 49 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 49 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 49 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 49 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 49 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 49 (statement_matched -> Return expression Semi .)


state 155

    (18) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (19) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (20) statement_unmatched -> If LParen expression RParen . statement
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (16) statement -> . statement_matched
    (17) statement -> . statement_unmatched
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 163
    statement_unmatched            shift and go to state 121
    statement                      shift and go to state 164
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 156

    (21) statement_matched -> While LParen expression RParen . statement_matched
    (22) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 165
    statement_unmatched            shift and go to state 166
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 157

    (23) statement_matched -> For LParen expression Semi . expression Semi expression RParen statement_matched
    (29) statement_matched -> For LParen expression Semi . Semi expression RParen statement_matched
    (33) statement_matched -> For LParen expression Semi . expression Semi RParen statement_matched
    (37) statement_matched -> For LParen expression Semi . Semi RParen statement_matched
    (25) statement_unmatched -> For LParen expression Semi . expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen expression Semi . Semi expression RParen statement_unmatched
    (35) statement_unmatched -> For LParen expression Semi . expression Semi RParen statement_unmatched
    (39) statement_unmatched -> For LParen expression Semi . Semi RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Semi            shift and go to state 168
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 167
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 158

    (43) statement_matched -> For LParen Semi Semi . expression RParen statement_matched
    (45) statement_matched -> For LParen Semi Semi . RParen statement_matched
    (44) statement_unmatched -> For LParen Semi Semi . expression RParen statement_unmatched
    (46) statement_unmatched -> For LParen Semi Semi . RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RParen          shift and go to state 170
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 169
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 159

    (27) statement_matched -> For LParen Semi expression . Semi expression RParen statement_matched
    (41) statement_matched -> For LParen Semi expression . Semi RParen statement_matched
    (28) statement_unmatched -> For LParen Semi expression . Semi expression RParen statement_unmatched
    (42) statement_unmatched -> For LParen Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 171


state 160

    (24) statement_matched -> For LParen declaration Semi . expression Semi expression RParen statement_matched
    (30) statement_matched -> For LParen declaration Semi . Semi expression RParen statement_matched
    (34) statement_matched -> For LParen declaration Semi . expression Semi RParen statement_matched
    (38) statement_matched -> For LParen declaration Semi . Semi RParen statement_matched
    (26) statement_unmatched -> For LParen declaration Semi . expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen declaration Semi . Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen declaration Semi . expression Semi RParen statement_unmatched
    (40) statement_unmatched -> For LParen declaration Semi . Semi RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Semi            shift and go to state 172
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 173
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 161

    (47) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 174
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 162

    (48) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 175
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 163

    (18) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (19) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (16) statement -> statement_matched .

    Else            shift and go to state 176
    RBrace          reduce using rule 16 (statement -> statement_matched .)
    If              reduce using rule 16 (statement -> statement_matched .)
    While           reduce using rule 16 (statement -> statement_matched .)
    For             reduce using rule 16 (statement -> statement_matched .)
    Do              reduce using rule 16 (statement -> statement_matched .)
    Return          reduce using rule 16 (statement -> statement_matched .)
    LBrace          reduce using rule 16 (statement -> statement_matched .)
    Break           reduce using rule 16 (statement -> statement_matched .)
    Continue        reduce using rule 16 (statement -> statement_matched .)
    Int             reduce using rule 16 (statement -> statement_matched .)
    Identifier      reduce using rule 16 (statement -> statement_matched .)
    Minus           reduce using rule 16 (statement -> statement_matched .)
    BitNot          reduce using rule 16 (statement -> statement_matched .)
    Not             reduce using rule 16 (statement -> statement_matched .)
    Integer         reduce using rule 16 (statement -> statement_matched .)
    LParen          reduce using rule 16 (statement -> statement_matched .)
    Semi            reduce using rule 16 (statement -> statement_matched .)


state 164

    (20) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 20 (statement_unmatched -> If LParen expression RParen statement .)


state 165

    (21) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 21 (statement_matched -> While LParen expression RParen statement_matched .)


state 166

    (22) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 22 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 167

    (23) statement_matched -> For LParen expression Semi expression . Semi expression RParen statement_matched
    (33) statement_matched -> For LParen expression Semi expression . Semi RParen statement_matched
    (25) statement_unmatched -> For LParen expression Semi expression . Semi expression RParen statement_unmatched
    (35) statement_unmatched -> For LParen expression Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 177


state 168

    (29) statement_matched -> For LParen expression Semi Semi . expression RParen statement_matched
    (37) statement_matched -> For LParen expression Semi Semi . RParen statement_matched
    (31) statement_unmatched -> For LParen expression Semi Semi . expression RParen statement_unmatched
    (39) statement_unmatched -> For LParen expression Semi Semi . RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RParen          shift and go to state 179
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 178
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 169

    (43) statement_matched -> For LParen Semi Semi expression . RParen statement_matched
    (44) statement_unmatched -> For LParen Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 180


state 170

    (45) statement_matched -> For LParen Semi Semi RParen . statement_matched
    (46) statement_unmatched -> For LParen Semi Semi RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    statement_matched              shift and go to state 181
    statement_unmatched            shift and go to state 182
    expression                     shift and go to state 122
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 171

    (27) statement_matched -> For LParen Semi expression Semi . expression RParen statement_matched
    (41) statement_matched -> For LParen Semi expression Semi . RParen statement_matched
    (28) statement_unmatched -> For LParen Semi expression Semi . expression RParen statement_unmatched
    (42) statement_unmatched -> For LParen Semi expression Semi . RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RParen          shift and go to state 184
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 183
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 172

    (30) statement_matched -> For LParen declaration Semi Semi . expression RParen statement_matched
    (38) statement_matched -> For LParen declaration Semi Semi . RParen statement_matched
    (32) statement_unmatched -> For LParen declaration Semi Semi . expression RParen statement_unmatched
    (40) statement_unmatched -> For LParen declaration Semi Semi . RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RParen          shift and go to state 186
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 185
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 173

    (24) statement_matched -> For LParen declaration Semi expression . Semi expression RParen statement_matched
    (34) statement_matched -> For LParen declaration Semi expression . Semi RParen statement_matched
    (26) statement_unmatched -> For LParen declaration Semi expression . Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen declaration Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 187


state 174

    (47) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 188


state 175

    (48) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 189


state 176

    (18) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (19) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 190
    statement_unmatched            shift and go to state 191
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 177

    (23) statement_matched -> For LParen expression Semi expression Semi . expression RParen statement_matched
    (33) statement_matched -> For LParen expression Semi expression Semi . RParen statement_matched
    (25) statement_unmatched -> For LParen expression Semi expression Semi . expression RParen statement_unmatched
    (35) statement_unmatched -> For LParen expression Semi expression Semi . RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RParen          shift and go to state 193
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 192
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 178

    (29) statement_matched -> For LParen expression Semi Semi expression . RParen statement_matched
    (31) statement_unmatched -> For LParen expression Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 194


state 179

    (37) statement_matched -> For LParen expression Semi Semi RParen . statement_matched
    (39) statement_unmatched -> For LParen expression Semi Semi RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 195
    statement_unmatched            shift and go to state 196
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 180

    (43) statement_matched -> For LParen Semi Semi expression RParen . statement_matched
    (44) statement_unmatched -> For LParen Semi Semi expression RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 197
    statement_unmatched            shift and go to state 198
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 181

    (45) statement_matched -> For LParen Semi Semi RParen statement_matched .

    RBrace          reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    If              reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    While           reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    For             reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Do              reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Return          reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Break           reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Continue        reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Int             reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Minus           reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Not             reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Integer         reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LParen          reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Semi            reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Else            reduce using rule 45 (statement_matched -> For LParen Semi Semi RParen statement_matched .)


state 182

    (46) statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    If              reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    While           reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    For             reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 46 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)


state 183

    (27) statement_matched -> For LParen Semi expression Semi expression . RParen statement_matched
    (28) statement_unmatched -> For LParen Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 199


state 184

    (41) statement_matched -> For LParen Semi expression Semi RParen . statement_matched
    (42) statement_unmatched -> For LParen Semi expression Semi RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 200
    statement_unmatched            shift and go to state 201
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 185

    (30) statement_matched -> For LParen declaration Semi Semi expression . RParen statement_matched
    (32) statement_unmatched -> For LParen declaration Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 202


state 186

    (38) statement_matched -> For LParen declaration Semi Semi RParen . statement_matched
    (40) statement_unmatched -> For LParen declaration Semi Semi RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    statement_matched              shift and go to state 203
    statement_unmatched            shift and go to state 204
    expression                     shift and go to state 122
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 187

    (24) statement_matched -> For LParen declaration Semi expression Semi . expression RParen statement_matched
    (34) statement_matched -> For LParen declaration Semi expression Semi . RParen statement_matched
    (26) statement_unmatched -> For LParen declaration Semi expression Semi . expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen declaration Semi expression Semi . RParen statement_unmatched
    (66) expression -> . assignment
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    RParen          shift and go to state 206
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 205
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 188

    (47) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 207


state 189

    (48) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 208


state 190

    (18) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 18 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 191

    (19) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 192

    (23) statement_matched -> For LParen expression Semi expression Semi expression . RParen statement_matched
    (25) statement_unmatched -> For LParen expression Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 209


state 193

    (33) statement_matched -> For LParen expression Semi expression Semi RParen . statement_matched
    (35) statement_unmatched -> For LParen expression Semi expression Semi RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 210
    statement_unmatched            shift and go to state 211
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 194

    (29) statement_matched -> For LParen expression Semi Semi expression RParen . statement_matched
    (31) statement_unmatched -> For LParen expression Semi Semi expression RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 212
    statement_unmatched            shift and go to state 213
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 195

    (37) statement_matched -> For LParen expression Semi Semi RParen statement_matched .

    RBrace          reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    If              reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    While           reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    For             reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Do              reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Return          reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Break           reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Continue        reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Int             reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Minus           reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Not             reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Integer         reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LParen          reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Semi            reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Else            reduce using rule 37 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)


state 196

    (39) statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    If              reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    While           reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    For             reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 39 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)


state 197

    (43) statement_matched -> For LParen Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    If              reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    While           reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    For             reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 43 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)


state 198

    (44) statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 44 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)


state 199

    (27) statement_matched -> For LParen Semi expression Semi expression RParen . statement_matched
    (28) statement_unmatched -> For LParen Semi expression Semi expression RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 214
    statement_unmatched            shift and go to state 215
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 200

    (41) statement_matched -> For LParen Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    If              reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    While           reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    For             reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 41 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)


state 201

    (42) statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 42 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)


state 202

    (30) statement_matched -> For LParen declaration Semi Semi expression RParen . statement_matched
    (32) statement_unmatched -> For LParen declaration Semi Semi expression RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 216
    statement_unmatched            shift and go to state 217
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 203

    (38) statement_matched -> For LParen declaration Semi Semi RParen statement_matched .

    RBrace          reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    If              reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    While           reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    For             reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Do              reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Return          reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Break           reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Continue        reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Int             reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Minus           reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Not             reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Integer         reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LParen          reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Semi            reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Else            reduce using rule 38 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)


state 204

    (40) statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    If              reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    While           reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    For             reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 40 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)


state 205

    (24) statement_matched -> For LParen declaration Semi expression Semi expression . RParen statement_matched
    (26) statement_unmatched -> For LParen declaration Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 218


state 206

    (34) statement_matched -> For LParen declaration Semi expression Semi RParen . statement_matched
    (36) statement_unmatched -> For LParen declaration Semi expression Semi RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 219
    statement_unmatched            shift and go to state 220
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 207

    (47) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 47 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 208

    (48) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 48 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 209

    (23) statement_matched -> For LParen expression Semi expression Semi expression RParen . statement_matched
    (25) statement_unmatched -> For LParen expression Semi expression Semi expression RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 221
    statement_unmatched            shift and go to state 222
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 210

    (33) statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    If              reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    While           reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    For             reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 33 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)


state 211

    (35) statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 35 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)


state 212

    (29) statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    If              reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    While           reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    For             reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 29 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)


state 213

    (31) statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 31 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)


state 214

    (27) statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 27 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)


state 215

    (28) statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 28 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)


state 216

    (30) statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    If              reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    While           reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    For             reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 30 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)


state 217

    (32) statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 32 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)


state 218

    (24) statement_matched -> For LParen declaration Semi expression Semi expression RParen . statement_matched
    (26) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen . statement_unmatched
    (18) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (21) statement_matched -> . While LParen expression RParen statement_matched
    (23) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (24) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (27) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (33) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (34) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (37) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (38) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (41) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (43) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (45) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (47) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (49) statement_matched -> . Return expression Semi
    (50) statement_matched -> . opt_expression Semi
    (51) statement_matched -> . LBrace block RBrace
    (52) statement_matched -> . Break Semi
    (53) statement_matched -> . Continue Semi
    (19) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (20) statement_unmatched -> . If LParen expression RParen statement
    (22) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (25) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (26) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (35) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (36) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (39) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (42) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (46) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (48) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (54) opt_expression -> . expression
    (55) opt_expression -> . empty
    (66) expression -> . assignment
    (1) empty -> .
    (67) assignment -> . conditional
    (89) assignment -> . Identifier Assign expression
    (90) assignment -> . unary Assign expression
    (68) conditional -> . logical_or
    (107) conditional -> . logical_or Question expression Colon conditional
    (78) unary -> . postfix
    (80) unary -> . Minus unary
    (81) unary -> . BitNot unary
    (82) unary -> . Not unary
    (69) logical_or -> . logical_and
    (91) logical_or -> . logical_or Or logical_and
    (79) postfix -> . primary
    (83) postfix -> . Identifier LParen arguments RParen
    (84) postfix -> . postfix LBracket expression RBracket
    (70) logical_and -> . bit_or
    (92) logical_and -> . logical_and And bit_or
    (108) primary -> . Integer
    (109) primary -> . Identifier
    (110) primary -> . LParen expression RParen
    (71) bit_or -> . xor
    (93) bit_or -> . bit_or BitOr xor
    (72) xor -> . bit_and
    (94) xor -> . xor Xor bit_and
    (73) bit_and -> . equality
    (95) bit_and -> . bit_and BitAnd equality
    (74) equality -> . relational
    (96) equality -> . equality NotEqual relational
    (97) equality -> . equality Equal relational
    (75) relational -> . additive
    (98) relational -> . relational Less additive
    (99) relational -> . relational Greater additive
    (100) relational -> . relational LessEqual additive
    (101) relational -> . relational GreaterEqual additive
    (76) additive -> . multiplicative
    (102) additive -> . additive Plus multiplicative
    (103) additive -> . additive Minus multiplicative
    (77) multiplicative -> . unary
    (104) multiplicative -> . multiplicative Mul unary
    (105) multiplicative -> . multiplicative Div unary
    (106) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 123
    While           shift and go to state 124
    For             shift and go to state 125
    Do              shift and go to state 126
    Return          shift and go to state 127
    LBrace          shift and go to state 115
    Break           shift and go to state 129
    Continue        shift and go to state 130
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 24
    BitNot          shift and go to state 25
    Not             shift and go to state 26
    Integer         shift and go to state 31
    LParen          shift and go to state 29

    expression                     shift and go to state 122
    statement_matched              shift and go to state 223
    statement_unmatched            shift and go to state 224
    opt_expression                 shift and go to state 128
    empty                          shift and go to state 131
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    unary                          shift and go to state 21
    logical_or                     shift and go to state 22
    postfix                        shift and go to state 23
    logical_and                    shift and go to state 27
    primary                        shift and go to state 28
    bit_or                         shift and go to state 30
    xor                            shift and go to state 32
    bit_and                        shift and go to state 33
    equality                       shift and go to state 34
    relational                     shift and go to state 35
    additive                       shift and go to state 36
    multiplicative                 shift and go to state 37

state 219

    (34) statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    If              reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    While           reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    For             reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 34 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)


state 220

    (36) statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 36 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)


state 221

    (23) statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 23 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)


state 222

    (25) statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 25 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)


state 223

    (24) statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 24 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)


state 224

    (26) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 26 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for Assign in state 8 resolved as shift
WARNING: shift/reduce conflict for Assign in state 17 resolved as shift
WARNING: shift/reduce conflict for LParen in state 17 resolved as shift
WARNING: shift/reduce conflict for Minus in state 36 resolved as shift
WARNING: shift/reduce conflict for LParen in state 53 resolved as shift
WARNING: shift/reduce conflict for Assign in state 72 resolved as shift
WARNING: shift/reduce conflict for Minus in state 94 resolved as shift
WARNING: shift/reduce conflict for Minus in state 95 resolved as shift
WARNING: shift/reduce conflict for Minus in state 96 resolved as shift
WARNING: shift/reduce conflict for Minus in state 97 resolved as shift
